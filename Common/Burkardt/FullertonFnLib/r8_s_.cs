using System;

namespace Burkardt.FullertonFnLib;

public static partial class FullertonLib
{
    public class r8ShiData
    {
        public int nshi;
        public double xsml;
        public r8E1Data edata = new();
    }
    public static double r8_shi(ref r8ShiData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SHI evaluates the hyperbolic sine integral Shi of an R8 argument.
        //
        //  Discussion:
        //
        //    Shi ( x ) = Integral ( 0 <= t <= x ) sinh ( t ) dt / t
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    12 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double R8_SHI, the hyperbolic sine integral 
        //    Shi evaluated at X.
        //
    {
        double[] shics = {
                0.0078372685688900950695200984317332E+00,
                0.0039227664934234563972697574427225E+00,
                0.0000041346787887617266746747908275E+00,
                0.0000000024707480372882742135145302E+00,
                0.0000000000009379295590763630457157E+00,
                0.0000000000000002451817019520867353E+00,
                0.0000000000000000000467416155257592E+00,
                0.0000000000000000000000067803072389E+00,
                0.0000000000000000000000000007731289E+00,
                0.0000000000000000000000000000000711E+00
            }
            ;
        double value = 0;

        switch (data.nshi)
        {
            case 0:
                data.nshi = r8_inits(shics, 10, 0.1 * r8_mach(3));
                data.xsml = Math.Sqrt(r8_mach(3));
                break;
        }

        double absx = Math.Abs(x);

        if (absx <= data.xsml)
        {
            value = x;
        }
        else
        {
            value = absx switch
            {
                <= 0.375 => x * (1.0 + r8_csevl(128.0 * x * x / 9.0 - 1.0, shics, data.nshi)),
                _ => 0.5 * (r8_ei(x) + r8_e1(ref data.edata, x))
            };
        }

        return value;
    }

    public class r8SiData
    {
        public int nsi;
        public double xsml;
        public r8SifgData sifgdata = new();
    }
        
    public static double r8_si(ref r8SiData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SI evaluates the sine integral Si of an R8 argument.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    13 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double R8_SI, the sine integral Si evaluated at X.
        //
    {
        double f = 0;
        double g = 0;
        const double pi2 = 1.57079632679489661923132169163975;
        double[] sics = {
                -0.1315646598184841928904275173000457,
                -0.2776578526973601892048287660157299,
                0.0354414054866659179749135464710086,
                -0.0025631631447933977658752788361530,
                0.0001162365390497009281264921482985,
                -0.0000035904327241606042670004347148,
                0.0000000802342123705710162308652976,
                -0.0000000013562997692540250649931846,
                0.0000000000179440721599736775567759,
                -0.0000000000001908387343087145490737,
                0.0000000000000016669989586824330853,
                -0.0000000000000000121730988368503042,
                0.0000000000000000000754181866993865,
                -0.0000000000000000000004014178842446,
                0.0000000000000000000000018553690716,
                -0.0000000000000000000000000075166966,
                0.0000000000000000000000000000269113,
                -0.0000000000000000000000000000000858
            }
            ;
        double value = 0;

        switch (data.nsi)
        {
            case 0:
                data.nsi = r8_inits(sics, 18, 0.1 * r8_mach(3));
                data.xsml = Math.Sqrt(r8_mach(3));
                break;
        }

        double absx = Math.Abs(x);

        if (absx < data.xsml)
        {
            value = x;
        }
        else
        {
            switch (absx)
            {
                case <= 4.0:
                    value = x * (0.75 + r8_csevl((x * x - 8.0) * 0.125, sics, data.nsi));
                    break;
                default:
                {
                    r8_sifg(ref data.sifgdata, absx, ref f, ref g);
                    double cosx = Math.Cos(absx);
                    value = x switch
                    {
                        < 0.0 => -value,
                        _ => pi2 - f * cosx - g * Math.Sin(x)
                    };

                    break;
                }
            }
        }

        return value;
    }

    public class r8SifgData
    {
        public int nf1;
        public int nf2;
        public int ng1;
        public int ng2;
        public int ng3;
        public double xbig;
        public double xbnd;
        public double xbndg;
        public double xmaxf;
        public double xmaxg;

    }
        
    public static void r8_sifg( ref r8SifgData data, double x, ref double f, ref double g )

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SIFG is a utility routine.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    14 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double &F, &G.
        //
    {
        double[] f1cs = {
                -0.1191081969051363610348201965828918,
                -0.0247823144996236247590074150823133,
                0.0011910281453357821268120363054457,
                -0.0000927027714388561748308600360706,
                0.0000093373141568270996868204582766,
                -0.0000011058287820557143938979426306,
                0.0000001464772071460162169336550799,
                -0.0000000210694496287689532601227548,
                0.0000000032293492366848236382857374,
                -0.0000000005206529617529375828014986,
                0.0000000000874878884570278750268316,
                -0.0000000000152176187056123668294574,
                0.0000000000027257192405419573900583,
                -0.0000000000005007053075968556290255,
                0.0000000000000940240902726068511779,
                -0.0000000000000180014444791803678336,
                0.0000000000000035062621432741785826,
                -0.0000000000000006935282926769149709,
                0.0000000000000001390925136454216568,
                -0.0000000000000000282486885074170585,
                0.0000000000000000058031305693579081,
                -0.0000000000000000012046901573375820,
                0.0000000000000000002525052443655940,
                -0.0000000000000000000533980268805594,
                0.0000000000000000000113855786274122,
                -0.0000000000000000000024462861505259,
                0.0000000000000000000005293659320439,
                -0.0000000000000000000001153184940277,
                0.0000000000000000000000252786568318,
                -0.0000000000000000000000055738645378,
                0.0000000000000000000000012358245621,
                -0.0000000000000000000000002754350842,
                0.0000000000000000000000000616906808,
                -0.0000000000000000000000000138817443,
                0.0000000000000000000000000031375329,
                -0.0000000000000000000000000007121249,
                0.0000000000000000000000000001622778,
                -0.0000000000000000000000000000371206,
                0.0000000000000000000000000000085221,
                -0.0000000000000000000000000000019633,
                0.0000000000000000000000000000004538,
                -0.0000000000000000000000000000001052,
                0.0000000000000000000000000000000245
            }
            ;
        double[] f2cs = {
                -0.03484092538970132330836049733745577,
                -0.01668422056779596873246786312278676,
                0.00067529012412377385045207859239727,
                -0.00005350666225447013628785577557429,
                0.00000626934217790075267050759431626,
                -0.00000095266388019916680677790414293,
                0.00000017456292242509880425504427666,
                -0.00000003687954030653093307097646628,
                0.00000000872026777051395264075816938,
                -0.00000000226019703919738748530423167,
                0.00000000063246249765250612520444877,
                -0.00000000018889118884717869240911480,
                0.00000000005967746729997813372620472,
                -0.00000000001980443117372239011196007,
                0.00000000000686413954772103383713264,
                -0.00000000000247310193070199106074890,
                0.00000000000092263594549941404196042,
                -0.00000000000035523634999261784497297,
                0.00000000000014076049625351591461820,
                -0.00000000000005726228499747652794311,
                0.00000000000002386537545413171810106,
                -0.00000000000001017141890764597142232,
                0.00000000000000442594531078364424968,
                -0.00000000000000196344933049189761979,
                0.00000000000000088688748314810461024,
                -0.00000000000000040743345027311546948,
                0.00000000000000019016837215675339859,
                -0.00000000000000009009707297478042442,
                0.00000000000000004329211274095668667,
                -0.00000000000000002108144465322479526,
                0.00000000000000001039637907026452274,
                -0.00000000000000000518891007948931936,
                0.00000000000000000261955324869899371,
                -0.00000000000000000133690399951301570,
                0.00000000000000000068941057702931664,
                -0.00000000000000000035905362610437250,
                0.00000000000000000018878077255791706,
                -0.00000000000000000010016125265594380,
                0.00000000000000000005360725691578228,
                -0.00000000000000000002893198974944827,
                0.00000000000000000001574065100202625,
                -0.00000000000000000000863027106431206,
                0.00000000000000000000476715602862288,
                -0.00000000000000000000265222739998504,
                0.00000000000000000000148582865063866,
                -0.00000000000000000000083797235923135,
                0.00000000000000000000047565916422711,
                -0.00000000000000000000027169073353112,
                0.00000000000000000000015612738881686,
                -0.00000000000000000000009024555078347,
                0.00000000000000000000005246097049119,
                -0.00000000000000000000003066450818697,
                0.00000000000000000000001801996250957,
                -0.00000000000000000000001064443050752,
                0.00000000000000000000000631942158881,
                -0.00000000000000000000000377013812246,
                0.00000000000000000000000225997542918,
                -0.00000000000000000000000136100844814,
                0.00000000000000000000000082333232003,
                -0.00000000000000000000000050025986091,
                0.00000000000000000000000030526245684,
                -0.00000000000000000000000018705164021,
                0.00000000000000000000000011508404393,
                -0.00000000000000000000000007108714611,
                0.00000000000000000000000004408065533,
                -0.00000000000000000000000002743760867,
                0.00000000000000000000000001714144851,
                -0.00000000000000000000000001074768860,
                0.00000000000000000000000000676259777,
                -0.00000000000000000000000000426981348,
                0.00000000000000000000000000270500637,
                -0.00000000000000000000000000171933331,
                0.00000000000000000000000000109636138,
                -0.00000000000000000000000000070132573,
                0.00000000000000000000000000045001784,
                -0.00000000000000000000000000028963835,
                0.00000000000000000000000000018697009,
                -0.00000000000000000000000000012104646,
                0.00000000000000000000000000007859065,
                -0.00000000000000000000000000005116867,
                0.00000000000000000000000000003340627,
                -0.00000000000000000000000000002186851,
                0.00000000000000000000000000001435340,
                -0.00000000000000000000000000000944523,
                0.00000000000000000000000000000623117,
                -0.00000000000000000000000000000412101,
                0.00000000000000000000000000000273208,
                -0.00000000000000000000000000000181558,
                0.00000000000000000000000000000120934,
                -0.00000000000000000000000000000080737,
                0.00000000000000000000000000000054022,
                -0.00000000000000000000000000000036227,
                0.00000000000000000000000000000024348,
                -0.00000000000000000000000000000016401,
                0.00000000000000000000000000000011074,
                -0.00000000000000000000000000000007497,
                0.00000000000000000000000000000005091,
                -0.00000000000000000000000000000003470,
                0.00000000000000000000000000000002377
            }
            ;
        double[] g1cs = {
                -0.3040578798253495954499726682091083,
                -0.0566890984597120587731339156118269,
                0.0039046158173275643919984071554082,
                -0.0003746075959202260618619339867489,
                0.0000435431556559843679552220840065,
                -0.0000057417294453025046561970723475,
                0.0000008282552104502629741937616492,
                -0.0000001278245892594642727883913223,
                0.0000000207978352948687884439257529,
                -0.0000000035313205921990798042032682,
                0.0000000006210824236308951068631449,
                -0.0000000001125215474446292649336987,
                0.0000000000209088917684421605267019,
                -0.0000000000039715831737681727689158,
                0.0000000000007690431314272089939005,
                -0.0000000000001514696742731613519826,
                0.0000000000000302892146552359684119,
                -0.0000000000000061399703834708825400,
                0.0000000000000012600605829510933553,
                -0.0000000000000002615029250939483683,
                0.0000000000000000548278844891796821,
                -0.0000000000000000116038182129526571,
                0.0000000000000000024771654107129795,
                -0.0000000000000000005330672753223389,
                0.0000000000000000001155666075598465,
                -0.0000000000000000000252280547744957,
                0.0000000000000000000055429038550786,
                -0.0000000000000000000012252208421297,
                0.0000000000000000000002723664318684,
                -0.0000000000000000000000608707831422,
                0.0000000000000000000000136724874476,
                -0.0000000000000000000000030856626806,
                0.0000000000000000000000006995212319,
                -0.0000000000000000000000001592587569,
                0.0000000000000000000000000364051056,
                -0.0000000000000000000000000083539465,
                0.0000000000000000000000000019240303,
                -0.0000000000000000000000000004446816,
                0.0000000000000000000000000001031182,
                -0.0000000000000000000000000000239887,
                0.0000000000000000000000000000055976,
                -0.0000000000000000000000000000013100,
                0.0000000000000000000000000000003074,
                -0.0000000000000000000000000000000723
            }
            ;
        double[] g2cs = {
                -0.1211802894731646263541834046858267,
                -0.0316761386394950286701407923505610,
                0.0013383199778862680163819429492182,
                -0.0000895511011392252425531905069518,
                0.0000079155562961718213115249467924,
                -0.0000008438793322241520181418982080,
                0.0000001029980425677530146647227274,
                -0.0000000139295750605183835795834444,
                0.0000000020422703959875980400677594,
                -0.0000000003196534694206427035434752,
                0.0000000000528147832657267698615312,
                -0.0000000000091339554672671033735289,
                0.0000000000016426251238967760444819,
                -0.0000000000003055897039322660002410,
                0.0000000000000585655825785779717892,
                -0.0000000000000115229197730940120563,
                0.0000000000000023209469119988537310,
                -0.0000000000000004774355834177535025,
                0.0000000000000001000996765800180573,
                -0.0000000000000000213533778082256704,
                0.0000000000000000046277190777367671,
                -0.0000000000000000010175807410227657,
                0.0000000000000000002267657399884672,
                -0.0000000000000000000511630776076426,
                0.0000000000000000000116767014913108,
                -0.0000000000000000000026935427672470,
                0.0000000000000000000006275665841146,
                -0.0000000000000000000001475880557531,
                0.0000000000000000000000350145314739,
                -0.0000000000000000000000083757732152,
                0.0000000000000000000000020191815152,
                -0.0000000000000000000000004903567705,
                0.0000000000000000000000001199123348,
                -0.0000000000000000000000000295170610,
                0.0000000000000000000000000073113112,
                -0.0000000000000000000000000018217843,
                0.0000000000000000000000000004565148,
                -0.0000000000000000000000000001150151,
                0.0000000000000000000000000000291267,
                -0.0000000000000000000000000000074125,
                0.0000000000000000000000000000018953,
                -0.0000000000000000000000000000004868,
                0.0000000000000000000000000000001256,
                -0.0000000000000000000000000000000325
            }
            ;
        double[] g3cs = {
                -0.0280574367809472928402815264335299,
                -0.0137271597162236975409100508089556,
                0.0002894032638760296027448941273751,
                -0.0000114129239391197145908743622517,
                0.0000006813965590726242997720207302,
                -0.0000000547952289604652363669058052,
                0.0000000055207429918212529109406521,
                -0.0000000006641464199322920022491428,
                0.0000000000922373663487041108564960,
                -0.0000000000144299088886682862611718,
                0.0000000000024963904892030710248705,
                -0.0000000000004708240675875244722971,
                0.0000000000000957217659216759988140,
                -0.0000000000000207889966095809030537,
                0.0000000000000047875099970877431627,
                -0.0000000000000011619070583377173759,
                0.0000000000000002956508969267836974,
                -0.0000000000000000785294988256492025,
                0.0000000000000000216922264368256612,
                -0.0000000000000000062113515831676342,
                0.0000000000000000018384568838450977,
                -0.0000000000000000005610887482137276,
                0.0000000000000000001761862805280062,
                -0.0000000000000000000568111050541451,
                0.0000000000000000000187786279582313,
                -0.0000000000000000000063531694151124,
                0.0000000000000000000021968802368238,
                -0.0000000000000000000007754666550395,
                0.0000000000000000000002791018356581,
                -0.0000000000000000000001023178525247,
                0.0000000000000000000000381693403919,
                -0.0000000000000000000000144767895606,
                0.0000000000000000000000055779512634,
                -0.0000000000000000000000021817239071,
                0.0000000000000000000000008656646309,
                -0.0000000000000000000000003482157895,
                0.0000000000000000000000001419188130,
                -0.0000000000000000000000000585714314,
                0.0000000000000000000000000244660482,
                -0.0000000000000000000000000103387099,
                0.0000000000000000000000000044177299,
                -0.0000000000000000000000000019080079,
                0.0000000000000000000000000008326038,
                -0.0000000000000000000000000003669553,
                0.0000000000000000000000000001632875,
                -0.0000000000000000000000000000733357,
                0.0000000000000000000000000000332327,
                -0.0000000000000000000000000000151906,
                0.0000000000000000000000000000070020,
                -0.0000000000000000000000000000032539,
                0.0000000000000000000000000000015240,
                -0.0000000000000000000000000000007193,
                0.0000000000000000000000000000003420,
                -0.0000000000000000000000000000001638,
                0.0000000000000000000000000000000790,
                -0.0000000000000000000000000000000383
            }
            ;

        switch (data.nf1)
        {
            case 0:
                double tol = 0.1 * r8_mach(3);
                data.nf1 = r8_inits(f1cs, 43, tol);
                data.nf2 = r8_inits(f2cs, 99, tol);
                data.ng1 = r8_inits(g1cs, 44, tol);
                data.ng2 = r8_inits(g2cs, 44, tol);
                data.ng3 = r8_inits(g3cs, 56, tol);
                data.xbig = Math.Sqrt(1.0 / r8_mach(3));
                data.xmaxf = Math.Exp(r8_min(-Math.Log(r8_mach(1)),
                    Math.Log(r8_mach(2))) - 0.01);
                data.xmaxg = 1.0 / Math.Sqrt(r8_mach(1));
                data.xbnd = Math.Sqrt(50.0);
                data.xbndg = Math.Sqrt(200.0);
                break;
        }

        switch (x)
        {
            case < 4.0:
                Console.WriteLine("");
                Console.WriteLine("R8_SIFG - Fatal error!");
                Console.WriteLine("  Approximation invalid for X < 4.");
                return;
        }

        if (x <= data.xbnd)
        {
            f = (1.0 + r8_csevl((1.0 / x / x - 0.04125)
                                / 0.02125, f1cs, data.nf1)) / x;
            g = (1.0 + r8_csevl((1.0 / x / x - 0.04125)
                                / 0.02125, g1cs, data.ng1)) / x / x;
        }
        else if (x <= data.xbig)
        {
            f = (1.0 + r8_csevl(100.0 / x / x - 1.0, f2cs, data.nf2) ) / x;
            if (x <= data.xbndg)
            {
                g = (1.0 + r8_csevl((10000.0 / x / x - 125.0)
                                    / 75.0, g2cs, data.ng2)) / x / x;
            }
            else
            {
                g = (1.0 + r8_csevl(400.0 / x / x - 1.0, g3cs, data.ng3)) / x / x;
            }
        }
        else
        {
            if (x < data.xmaxf)
            {
                f = 1.0 / x;
            }
            else
            {
                f = 0.0;
            }

            if (x < data.xmaxg)
            {
                g = 1.0 / x / x;
            }
            else
            {
                g = 0.0;
            }
        }
    }

    public static double r8_sign(double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SIGN returns the sign of an R8.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    18 October 2004
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double X, the number whose sign is desired.
        //
        //    Output, double R8_SIGN, the sign of X.
        //
    {
        double value = x switch
        {
            < 0.0 => -1.0,
            _ => 1.0
        };

        return value;
    }

    public class r8SinData
    {
        public int ntsn;
        public double xmax;
        public double xsml;
        public double xwarn;

        public r8SqrtData sqrtdata = new();
    }
    public static double r8_sin(ref r8SinData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SIN evaluates the sine of an R8 argument.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    15 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double R8_SIN, the sine of X.
        //
    {
        const double pi2rec = 0.63661977236758134307553505349006;
        const double pihi = 3.140625;
        const double pilo = 9.6765358979323846264338327950288E-04;
        const double pirec = 0.31830988618379067153776752674503;
        double[] sincs = {
                -0.374991154955873175839919279977323464,
                -0.181603155237250201863830316158004754,
                0.005804709274598633559427341722857921,
                -0.000086954311779340757113212316353178,
                0.000000754370148088851481006839927030,
                -0.000000004267129665055961107126829906,
                0.000000000016980422945488168181824792,
                -0.000000000000050120578889961870929524,
                0.000000000000000114101026680010675628,
                -0.000000000000000000206437504424783134,
                0.000000000000000000000303969595918706,
                -0.000000000000000000000000371357734157,
                0.000000000000000000000000000382486123,
                -0.000000000000000000000000000000336623,
                0.000000000000000000000000000000000256
            }
            ;
        double value;

        switch (data.ntsn)
        {
            case 0:
                data.ntsn = r8_inits(sincs, 15, 0.1 * r8_mach(3));
                data.xsml = r8_sqrt( ref data.sqrtdata,2.0 * r8_mach(3));
                data.xmax = 1.0 / r8_mach(4);
                data.xwarn = r8_sqrt(ref data.sqrtdata,data.xmax);
                break;
        }

        double y = Math.Abs(x);

        if (data.xmax < y)
        {
            Console.WriteLine("");
            Console.WriteLine("R8_SIN - Warning!");
            Console.WriteLine("  No precision because |X| is big.");
            value = 0.0;
            return value;
        }

        if (data.xwarn < y)
        {
            Console.WriteLine("");
            Console.WriteLine("R8_SIN - Warning!");
            Console.WriteLine("  Answer < half precision because |X| is big.");
        }

        value = x;
        if (y < data.xsml)
        {
            return value;
        }

        double xn = (int) (y * pirec + 0.5);
        int n2 = (int) (r8_mod(xn, 2.0) + 0.5);

        double sgn = x;
        if (n2 != 0)
        {
            sgn = -sgn;
        }

        double f = y - xn * pihi - xn * pilo;
        xn = 2.0 * (f * pi2rec) * (f * pi2rec) - 1.0;
        value = f + f * r8_csevl(xn, sincs, data.ntsn);

        switch (sgn)
        {
            case < 0.0:
                value = -value;
                break;
        }

        value = value switch
        {
            < -1.0 => -1.0,
            > 1.0 => +1.0,
            _ => value
        };

        return value;
    }

    public static double r8_sin_deg(double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SIN_DEG evaluates the sine of an R8 argument in degrees.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    12 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument in degrees.
        //
        //    Output, double R8_SIN_DEG, the sine of X.
        //
    {
        const double raddeg = 0.017453292519943295769236907684886E+00;

        double value = Math.Sin(raddeg * x);

        if (r8_mod(x, 90.0E+00) != 0.0E+00)
        {
            return value;
        }

        int n = (int) (Math.Abs(x) / 90.0E+00 + 0.5E+00);
        n %= 2;

        switch (n)
        {
            case 0:
                value = 0.0E+00;
                break;
            default:
            {
                value = value switch
                {
                    < 0.0E+00 => -1.0E+00,
                    _ => +1.0E+00
                };

                break;
            }
        }

        return value;
    }

    public class r8SinhData
    {
        public int nterms;
        public double sqeps;
        public double ymax;

    }
    public static double r8_sinh(ref r8SinhData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SINH evaluates the hyperbolic sine of an R8 argument.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    11 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double R8_SINH, the hyperbolic sine of X.
        //
    {
        double[] sinhcs = {
                +0.17304219404717963167588384698501E+00,
                +0.87594221922760477154900263454440E-01,
                +0.10794777745671327502427270651579E-02,
                +0.63748492607547504815685554571850E-05,
                +0.22023664049230530159190496019502E-07,
                +0.49879401804158493149425807203661E-10,
                +0.79730535541157304814411480441186E-13,
                +0.94731587130725443342927317226666E-16,
                +0.86934920504480078871023098666666E-19,
                +0.63469394403318040457397333333333E-22,
                +0.37740337870858485738666666666666E-25,
                +0.18630213719570056533333333333333E-28,
                +0.77568437166506666666666666666666E-32
            }
            ;
        double value;

        switch (data.nterms)
        {
            case 0:
                data.nterms = r8_inits(sinhcs, 13, 0.1 * r8_mach(3));
                data.sqeps = Math.Sqrt(6.0 * r8_mach(3));
                data.ymax = 1.0 / Math.Sqrt(r8_mach(3));
                break;
        }

        double y = Math.Abs(x);

        if (y <= data.sqeps)
        {
            value = x;
        }
        else
        {
            switch (y)
            {
                case <= 1.0:
                    value = x * (1.0 + r8_csevl(2.0 * x * x - 1.0, sinhcs, data.nterms));
                    break;
                default:
                {
                    y = Math.Exp(y);

                    if (data.ymax <= y)
                    {
                        value = 0.5 * y;
                    }
                    else
                    {
                        value = 0.5 * (y - 1.0 / y);
                    }

                    value = x switch
                    {
                        < 0.0 => -value,
                        _ => value
                    };

                    break;
                }
            }
        }

        return value;
    }

    public class r8SpenceData
    {
        public int nspenc;
        public double xbig;

    }
    public static double r8_spence(ref r8SpenceData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SPENCE evaluates a form of Spence's function for an R8 argument.
        //
        //  Discussion:
        //
        //    This function evaluates a form of Spence's function defined by
        //
        //      f(x) = Integral ( 0 <= y <= x ) - log ( abs ( 1 - y ) ) / y dy
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    15 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Milton Abramowitz, Irene Stegun,
        //    Handbook of Mathematical Functions, page 1004,
        //    National Bureau of Standards, 1964,
        //    ISBN: 0-486-61272-4,
        //    LC: QA47.A34.
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //    K Mitchell,
        //    Tables of the function Integral ( 0 < y < x ) - log | 1 - y | dy / y
        //    with an account of some properties of this and related functions,
        //    Philosophical Magazine,
        //    Volume 40, pages 351-368, 1949.
        //
        //  Parameters:
        //
        //    Input, double X, the argument.
        //
        //    Output, double R8_SPENCE, Spence's function evaluated at X.
        //
    {
        double aln;
        const double pi26 = +1.644934066848226436472415166646025189219;
        double[] spencs =  {
                +0.1527365598892405872946684910028,
                +0.8169658058051014403501838185271E-01,
                +0.5814157140778730872977350641182E-02,
                +0.5371619814541527542247889005319E-03,
                +0.5724704675185826233210603054782E-04,
                +0.6674546121649336343607835438589E-05,
                +0.8276467339715676981584391689011E-06,
                +0.1073315673030678951270005873354E-06,
                +0.1440077294303239402334590331513E-07,
                +0.1984442029965906367898877139608E-08,
                +0.2794005822163638720201994821615E-09,
                +0.4003991310883311823072580445908E-10,
                +0.5823462892044638471368135835757E-11,
                +0.8576708692638689278097914771224E-12,
                +0.1276862586280193045989483033433E-12,
                +0.1918826209042517081162380416062E-13,
                +0.2907319206977138177795799719673E-14,
                +0.4437112685276780462557473641745E-15,
                +0.6815727787414599527867359135607E-16,
                +0.1053017386015574429547019416644E-16,
                +0.1635389806752377100051821734570E-17,
                +0.2551852874940463932310901642581E-18,
                +0.3999020621999360112770470379519E-19,
                +0.6291501645216811876514149171199E-20,
                +0.9933827435675677643803887752533E-21,
                +0.1573679570749964816721763805866E-21,
                +0.2500595316849476129369270954666E-22,
                +0.3984740918383811139210663253333E-23,
                +0.6366473210082843892691326293333E-24,
                +0.1019674287239678367077061973333E-24,
                +0.1636881058913518841111074133333E-25,
                +0.2633310439417650117345279999999E-26,
                +0.4244811560123976817224362666666E-27,
                +0.6855411983680052916824746666666E-28,
                +0.1109122433438056434018986666666E-28,
                +0.1797431304999891457365333333333E-29,
                +0.2917505845976095173290666666666E-30,
                +0.4742646808928671061333333333333E-31
            }
            ;
        double value = 0;

        switch (data.nspenc)
        {
            case 0:
                data.nspenc = r8_inits(spencs, 38, 0.1 * r8_mach(3));
                data.xbig = 1.0 / r8_mach(3);
                break;
        }

        if (x <= -data.xbig)
        {
            aln = Math.Log(1.0 - x);
            value = -pi26 - 0.5 * aln * (2.0 * Math.Log(-x) - aln);
        }
        else
        {
            switch (x)
            {
                case <= -1.0:
                    aln = Math.Log(1.0 - x);

                    value = -pi26 - 0.5 * aln * (2.0
                        * Math.Log(-x) - aln) + (1.0 + r8_csevl(
                        4.0 / (1.0 - x) - 1.0, spencs, data.nspenc)) / (1.0 - x);
                    break;
                case <= 0.0:
                    value = -0.5 * Math.Log(1.0 - x)
                                 * Math.Log(1.0 - x) - x * (1.0 + r8_csevl(
                        4.0 * x / (x - 1.0) - 1.0, spencs, data.nspenc)) / (x - 1.0);
                    break;
                case <= 0.5:
                    value = x * (1.0 + r8_csevl(4.0 * x - 1.0, spencs, data.nspenc));
                    break;
                case < 1.0:
                    value = pi26 - Math.Log(x) * Math.Log(1.0 - x)
                                 - (1.0 - x) * (1.0 + r8_csevl(4.0
                                     * (1.0 - x) - 1.0, spencs, data.nspenc));
                    break;
                case 1.0:
                    value = pi26;
                    break;
                case <= 2.0:
                    value = pi26 - 0.5 * Math.Log(x)
                                       * Math.Log((x - 1.0) * (x - 1.0) / x)
                            + (x - 1.0) * (1.0 + r8_csevl(4.0
                                * (x - 1.0) / x - 1.0, spencs, data.nspenc)) / x;
                    break;
                default:
                {
                    if (x < data.xbig)
                    {
                        value = 2.0 * pi26 - 0.5 * Math.Log(x) * Math.Log(x)
                                           - (1.0 + r8_csevl(4.0 / x - 1.0, spencs, data.nspenc)) / x;
                    }
                    else
                    {
                        value = 2.0 * pi26 - 0.5 * Math.Log(x) * Math.Log(x);
                    }

                    break;
                }
            }
        }

        return value;
    }

    public class r8SqrtData
    {
        public int niter;

        public r8LogData logdata = new();
        public r8PakData pakdata = new();
    }
    public static double r8_sqrt(ref r8SqrtData data, double x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    R8_SQRT computes the square root of an R8.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    15 September 2011
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Wayne Fullerton.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Wayne Fullerton,
        //    Portable Special Function Routines,
        //    in Portability of Numerical Software,
        //    edited by Wayne Cowell,
        //    Lecture Notes in Computer Science, Volume 57,
        //    Springer 1977,
        //    ISBN: 978-3-540-08446-4,
        //    LC: QA297.W65.
        //
        //  Parameters:
        //
        //    Input, double X, the number whose square root is desired.
        //
        //    Output, double R8_SQRT, the square root of X.
        //
    {
        int n = 0;
        double[] sqrt2 = {
                0.70710678118654752440084436210485,
                1.0,
                1.41421356237309504880168872420970
            }
            ;
        double value;
        double y = 0;

        data.niter = data.niter switch
        {
            0 => (int) (1.443 * r8_log(ref data.logdata, -0.104 * r8_log(ref data.logdata, 0.1 * r8_mach(3))) + 1.0),
            _ => data.niter
        };

        switch (x)
        {
            case < 0.0:
                Console.WriteLine("");
                Console.WriteLine("R8_SQRT - Fatal error!");
                Console.WriteLine("  X is negative.");
                return 1;
            case 0.0:
                value = 0.0;
                break;
            default:
            {
                r8_upak(x, ref y, ref n);
                int ixpnt = n / 2;
                int irem = n - 2 * ixpnt + 2;
                value = 0.261599 + y * (1.114292 + y * (-0.516888 + y * 0.141067));

                int iter;
                for (iter = 1; iter <= data.niter; iter++)
                {
                    value += 0.5 * (y - value * value) / value;
                }

                value = r8_pak( ref data.pakdata, sqrt2[irem - 1] * value, ixpnt);
                break;
            }
        }

        return value;
    }
}