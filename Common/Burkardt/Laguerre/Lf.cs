using System;
using Burkardt.MatrixNS;
using Burkardt.Types;

namespace Burkardt.Laguerre;

public static partial class Functions
{
    public static double[] lf_function(int mm, int n, double alpha, double[] x)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    LF_FUNCTION evaluates the Laguerre function Lf(n,alpha,x).
        //
        //  Recursion:
        //
        //    Lf(0,ALPHA,X) = 1
        //    Lf(1,ALPHA,X) = 1+ALPHA-X
        //
        //    Lf(N,ALPHA,X) = (2*N-1+ALPHA-X)/N * Lf(N-1,ALPHA,X) 
        //                      - (N-1+ALPHA)/N * Lf(N-2,ALPHA,X)
        //
        //  Restrictions:
        //
        //    -1 < ALPHA
        //
        //  Special values:
        //
        //    Lf(N,0,X) = L(N,X).
        //    Lf(N,ALPHA,X) = LM(N,ALPHA,X) for ALPHA integral.
        //
        //  Norm:
        //
        //    Integral ( 0 <= X < +oo ) exp ( - X ) * Lf(N,ALPHA,X)^2 dX
        //    = Gamma ( N + ALPHA + 1 ) / N!
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    10 March 2012
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Milton Abramowitz, Irene Stegun,
        //    Handbook of Mathematical Functions,
        //    National Bureau of Standards, 1964,
        //    ISBN: 0-486-61272-4,
        //    LC: QA47.A34.
        //
        //  Parameters:
        //
        //    Input, int MM, the number of evaluation points.
        //
        //    Input, int N, the highest order polynomial to compute.
        //
        //    Input, double ALPHA, the parameter.  -1.0 < ALPHA.
        //
        //    Input, double X[MM], the evaluation points.
        //
        //    Output, double LM_POLYNOMIAL[MM*(N+1)], the function values.
        //
    {
        int i;
        int j;

        switch (n)
        {
            case < 0:
                return null;
        }

        double[] v = new double[mm * (n + 1)];

        for (i = 0; i < mm; i++)
        {
            v[i + 0 * mm] = 1.0;
        }

        switch (n)
        {
            case 0:
                return v;
        }

        for (i = 0; i < mm; i++)
        {
            v[i + 1 * mm] = alpha + 1.0 - x[i];
        }

        for (j = 2; j <= n; j++)
        {
            for (i = 0; i < mm; i++)
            {
                v[i + j * mm] = ((alpha + (2 * i - 1) - x[i]) * v[i + (j - 1) * mm]
                                 + (-alpha + (-i + 1)) * v[i + (j - 2) * mm])
                                / i;
            }
        }

        return v;
    }

    public static void lf_function_values(ref int n_data, ref int n, ref double a, ref double x,
            ref double fx )

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    LF_FUNCTION_VALUES: some values of the Laguerre function Lf(n,alpha,x).
        //
        //  Discussion:
        //
        //    In Mathematica, the function can be evaluated by:
        //
        //      LaguerreL[n,a,x]
        //
        //    The functions satisfy the following differential equation:
        //
        //      X * Y'' + (ALPHA+1-X) * Y' + N * Y = 0;
        //
        //    Function values can be generated by the recursion:
        //
        //      Lf(0,ALPHA,X) = 1
        //      Lf(1,ALPHA,X) = 1+ALPHA-X
        //
        //      Lf(N,ALPHA,X) = ( (2*N-1+ALPHA-X) * Lf(N-1,ALPHA,X)
        //                     - (N-1+ALPHA) * Lf(N-2,ALPHA,X) ) / N
        //
        //    The parameter ALPHA is required to be greater than -1.
        //
        //    For ALPHA = 0, the generalized Laguerre function Lf(N,ALPHA,X)
        //    is equal to the Laguerre polynomial L(N,X).
        //
        //    For ALPHA integral, the generalized Laguerre function
        //    Lf(N,ALPHA,X) equals the associated Laguerre polynomial Lm(N,ALPHA,X).
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    21 August 2004
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Stephen Wolfram,
        //    The Mathematica Book,
        //    Fourth Edition,
        //    Cambridge University Press, 1999,
        //    ISBN: 0-521-64314-7,
        //    LC: QA76.95.W65.
        //
        //  Parameters:
        //
        //    Input/output, int &N_DATA.  The user sets N_DATA to 0 before the
        //    first call.  On each call, the routine increments N_DATA by 1, and
        //    returns the corresponding data; when there is no more data, the
        //    output value of N_DATA will be 0 again.
        //
        //    Output, int &N, the order of the function.
        //
        //    Output, double &A, the parameter.
        //
        //    Output, double &X, the point where the function is evaluated.
        //
        //    Output, double &FX, the value of the function.
        //
    {
        const int N_MAX = 20;

        double[] a_vec =
            {
                0.00E+00,
                0.25E+00,
                0.50E+00,
                0.75E+00,
                1.50E+00,
                2.50E+00,
                5.00E+00,
                1.20E+00,
                1.20E+00,
                1.20E+00,
                1.20E+00,
                1.20E+00,
                1.20E+00,
                5.20E+00,
                5.20E+00,
                5.20E+00,
                5.20E+00,
                5.20E+00,
                5.20E+00,
                5.20E+00
            }
            ;

        double[] fx_vec =
            {
                0.3726399739583333E-01,
                0.3494791666666667E+00,
                0.8710042317708333E+00,
                0.1672395833333333E+01,
                0.6657625325520833E+01,
                0.2395726725260417E+02,
                0.2031344319661458E+03,
                0.1284193996800000E+02,
                0.5359924801587302E+01,
                0.9204589064126984E+00,
                -0.1341585114857143E+01,
                -0.2119726307555556E+01,
                -0.1959193658349206E+01,
                0.1000000000000000E+01,
                0.5450000000000000E+01,
                0.1720125000000000E+02,
                0.4110393750000000E+02,
                0.8239745859375000E+02,
                0.1460179186171875E+03,
                0.2359204608298828E+03
            }
            ;

        int[] n_vec =
            {
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                8,
                8,
                8,
                8,
                8,
                8,
                0,
                1,
                2,
                3,
                4,
                5,
                6
            }
            ;

        double[] x_vec =
            {
                0.25E+00,
                0.25E+00,
                0.25E+00,
                0.25E+00,
                0.25E+00,
                0.25E+00,
                0.25E+00,
                0.00E+00,
                0.20E+00,
                0.40E+00,
                0.60E+00,
                0.80E+00,
                1.00E+00,
                0.75E+00,
                0.75E+00,
                0.75E+00,
                0.75E+00,
                0.75E+00,
                0.75E+00,
                0.75E+00
            }
            ;

        n_data = n_data switch
        {
            < 0 => 0,
            _ => n_data
        };

        n_data += 1;

        if (N_MAX < n_data)
        {
            n_data = 0;
            n = 0;
            a = 0.0;
            x = 0.0;
            fx = 0.0;
        }
        else
        {
            n = n_vec[n_data - 1];
            a = a_vec[n_data - 1];
            x = x_vec[n_data - 1];
            fx = fx_vec[n_data - 1];
        }
    }

    public static double[] lf_function_zeros(int n, double alpha)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    LF_FUNCTION_ZEROS returns the zeros of Lf(n,alpha,x).
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    10 March 2012
        //
        //  Author:
        //
        //    John Burkardt.
        //
        //  Reference:
        //
        //    Sylvan Elhay, Jaroslav Kautsky,
        //    Algorithm 655: IQPACK, FORTRAN Subroutines for the Weights of
        //    Interpolatory Quadrature,
        //    ACM Transactions on Mathematical Software,
        //    Volume 13, Number 4, December 1987, pages 399-415.
        //
        //  Parameters:
        //
        //    Input, int N, the order.
        //
        //    Input, double ALPHA, the exponent of the X factor.
        //    ALPHA must be nonnegative.
        //
        //    Output, double LF_FUNCTION_ZEROS[N], the zeros.
        //
    {
        int i;
        double i_r8;
        //
        //  Define the zero-th moment.
        //
        double zemu = typeMethods.r8_gamma(alpha + 1.0);
        //
        //  Define the Jacobi matrix.
        //
        double[] bj = new double[n];
        for (i = 0; i < n; i++)
        {
            i_r8 = i;
            bj[i] = (i_r8 + 1.0) * (i_r8 + 1.0 + alpha);
        }

        double[] x = new double[n];
        for (i = 0; i < n; i++)
        {
            i_r8 = i;
            x[i] = 2.0 * i_r8 + 1.0 + alpha;
        }

        double[] w = new double[n];
        w[0] = Math.Sqrt(zemu);
        for (i = 1; i < n; i++)
        {
            w[i] = 0.0;
        }

        //
        //  Diagonalize the Jacobi matrix.
        //
        IMTQLX.imtqlx(n, ref x, ref bj, ref w);

        for (i = 0; i < n; i++)
        {
            w[i] *= w[i];
        }

        return x;
    }

    public static double lf_integral(int n, double alpha)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    LF_INTEGRAL evaluates a monomial integral associated with Lf(n,alpha,x).
        //
        //  Discussion:
        //
        //    The integral:
        //
        //      integral ( 0 <= x < +oo ) x^n * x^alpha * exp ( -x ) dx
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    10 March 2012
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int N, the exponent.
        //    0 <= N.
        //
        //    Input, double ALPHA, the exponent of X in the weight function.
        //
        //    Output, double LF_INTEGRAL, the value of the integral.
        //
    {
        double arg = alpha + (n + 1);

        double value = typeMethods.r8_gamma(arg);

        return value;
    }

    public static void lf_quadrature_rule(int n, double alpha, ref double[] x, ref double[] w )

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    LF_QUADRATURE_RULE: Gauss-Laguerre quadrature rule for Lf(n,alpha,x);
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    10 March 2012
        //
        //  Author:
        //
        //    John Burkardt.
        //
        //  Reference:
        //
        //    Sylvan Elhay, Jaroslav Kautsky,
        //    Algorithm 655: IQPACK, FORTRAN Subroutines for the Weights of
        //    Interpolatory Quadrature,
        //    ACM Transactions on Mathematical Software,
        //    Volume 13, Number 4, December 1987, pages 399-415.
        //
        //  Parameters:
        //
        //    Input, int N, the order.
        //
        //    Input, double ALPHA, the exponent of the X factor.
        //    ALPHA must be nonnegative.
        //
        //    Output, double X[N], the abscissas.
        //
        //    Output, double W[N], the weights.
        //
    {
        int i;
        double i_r8;
        //
        //  Define the zero-th moment.
        //
        double zemu = typeMethods.r8_gamma(alpha + 1.0);
        //
        //  Define the Jacobi matrix.
        //
        double[] bj = new double[n];
        for (i = 0; i < n; i++)
        {
            i_r8 = i;
            bj[i] = (i_r8 + 1.0) * (i_r8 + 1.0 + alpha);
        }

        for (i = 0; i < n; i++)
        {
            i_r8 = i;
            x[i] = 2.0 * i_r8 + 1.0 + alpha;
        }

        w[0] = Math.Sqrt(zemu);
        for (i = 1; i < n; i++)
        {
            w[i] = 0.0;
        }

        //
        //  Diagonalize the Jacobi matrix.
        //
        IMTQLX.imtqlx(n, ref x, ref bj, ref w);

        for (i = 0; i < n; i++)
        {
            w[i] *= w[i];
        }
    }

}