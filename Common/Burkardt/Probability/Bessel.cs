using System;
using Burkardt.Types;

namespace Burkardt.Probability;

public static class Bessel
{
    public static double bessel_i0(double arg)
        //****************************************************************************80
        //
        //  Purpose:
        //
        //    BESSEL_I0 evaluates the modified Bessel function I0.
        //
        //  Discussion:
        //
        //    The main computation evaluates slightly modified forms of
        //    minimax approximations generated by Blair and Edwards, Chalk
        //    River (Atomic Energy of Canada Limited) Report AECL-4928,
        //    October, 1974.  This transportable program is patterned after
        //    the machine dependent FUNPACK packet NATSI0, but cannot match
        //    that version for efficiency or accuracy.  This version uses
        //    rational functions that theoretically approximate I-SUB-0(X)
        //    to at least 18 significant decimal digits.
        //
        //  Machine dependent constants:
        //
        //    beta   = Radix for the floating-point system
        //    maxexp = Smallest power of beta that overflows
        //    XSMALL = Positive argument such that 1.0 - X = 1.0 to
        //             machine precision for all ABS(X) .LE. XSMALL.
        //    XMAX =   Largest argument acceptable to BESI0;  Solution to
        //             equation:
        //               W(X) * (1+1/(8*X)+9/(128*X^2) = beta^maxexp
        //             where  W(X) = EXP(X)/sqrt(2*PI*X)
        //
        //    Approximate values for some important machines are:
        //
        //                             beta       maxexp       XSMALL
        //
        //    CRAY-1        (S.P.)       2         8191       3.55D-15
        //    Cyber 180/855
        //      under NOS   (S.P.)       2         1070       3.55D-15
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (S.P.)       2          128       2.98D-8
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (D.P.)       2         1024       5.55D-17
        //    IBM 3033      (D.P.)      16           63       6.95D-18
        //    VAX           (S.P.)       2          127       2.98D-8
        //    VAX D-Format  (D.P.)       2          127       6.95D-18
        //    VAX G-Format  (D.P.)       2         1023       5.55D-17
        //
        //
        //                                  XMAX
        //
        //    CRAY-1        (S.P.)       5682.810
        //    Cyber 180/855
        //      under NOS   (S.P.)       745.893
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (S.P.)        91.900
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (D.P.)       713.986
        //    IBM 3033      (D.P.)       178.182
        //    VAX           (S.P.)        91.203
        //    VAX D-Format  (D.P.)        91.203
        //    VAX G-Format  (D.P.)       713.293
        //
        //  Author:
        //
        //    Original FORTRAN77 version by W. J. Cody and L. Stoltz.
        //    C++ version by John Burkardt.
        //
        //  Parameters:
        //
        //    Input, double ARG, the argument.
        //
        //    Output, double BESSEL_I0, the value of the modified Bessel function
        //    of the first kind.
        //
    {
        const double exp40 = 2.353852668370199854E+17;
        double[] p =
        {
            -5.2487866627945699800E-18,
            -1.5982226675653184646E-14,
            -2.6843448573468483278E-11,
            -3.0517226450451067446E-08,
            -2.5172644670688975051E-05,
            -1.5453977791786851041E-02,
            -7.0935347449210549190,
            -2.4125195876041896775E+03,
            -5.9545626019847898221E+05,
            -1.0313066708737980747E+08,
            -1.1912746104985237192E+10,
            -8.4925101247114157499E+11,
            -3.2940087627407749166E+13,
            -5.5050369673018427753E+14,
            -2.2335582639474375249E+15
        };
        double[] pp =
        {
            -3.9843750000000000000E-01,
            2.9205384596336793945,
            -2.4708469169133954315,
            4.7914889422856814203E-01,
            -3.7384991926068969150E-03,
            -2.6801520353328635310E-03,
            9.9168777670983678974E-05,
            -2.1877128189032726730E-06
        };
        double[] q =
        {
            -3.7277560179962773046E+03,
            6.5158506418655165707E+06,
            -6.5626560740833869295E+09,
            3.7604188704092954661E+12,
            -9.7087946179594019126E+14
        };
        double[] qq =
        {
            -3.1446690275135491500E+01,
            8.5539563258012929600E+01,
            -6.0228002066743340583E+01,
            1.3982595353892851542E+01,
            -1.1151759188741312645,
            3.2547697594819615062E-02,
            -5.5194330231005480228E-04
        };
        const double rec15 = 6.6666666666666666666E-02;
        double value = 0;
        const double xmax = 91.9;
        const double xsmall = 2.98E-08;

        double x = Math.Abs(arg);

        if (x < xsmall)
        {
            value = 1.0;
        }
        else
        {
            double sump;
            double sumq;
            double xx;
            switch (x)
            {
                case < 15.0:
                {
                    //
                    //  XSMALL <= ABS(ARG) < 15.0
                    //
                    xx = x * x;
                    sump = p[0];
                    int i;
                    for (i = 1; i < 15; i++)
                    {
                        sump = sump * xx + p[i];
                    }

                    xx -= 225.0;
                    sumq = ((((
                                        xx + q[0])
                                    * xx + q[1])
                                * xx + q[2])
                            * xx + q[3])
                        * xx + q[4];

                    value = sump / sumq;
                    break;
                }
                case >= 15.0 and > xmax:
                    value = typeMethods.r8_huge();
                    break;
                case >= 15.0:
                {
                    //
                    //  15.0 <= ABS(ARG)
                    //
                    xx = 1.0 / x - rec15;

                    sump = ((((((
                                                pp[0]
                                                * xx + pp[1])
                                            * xx + pp[2])
                                        * xx + pp[3])
                                    * xx + pp[4])
                                * xx + pp[5])
                            * xx + pp[6])
                        * xx + pp[7];

                    sumq = ((((((
                                                xx + qq[0])
                                            * xx + qq[1])
                                        * xx + qq[2])
                                    * xx + qq[3])
                                * xx + qq[4])
                            * xx + qq[5])
                        * xx + qq[6];

                    value = sump / sumq;
                    //
                    //  Calculation reformulated to avoid premature overflow.
                    //
                    double a;
                    double b;
                    if (x <= xmax - 15.0)
                    {
                        a = Math.Exp(x);
                        b = 1.0;
                    }
                    else
                    {
                        a = Math.Exp(x - 40.0);
                        b = exp40;
                    }

                    value = (value * a - pp[0] * a) / Math.Sqrt(x) * b;
                    break;
                }
            }
        }

        return value;
    }

    public static void bessel_i0_values(ref int n_data, ref double x, ref double fx )
        //****************************************************************************80
        //
        //  Purpose:
        //
        //    BESSEL_I0_VALUES returns some values of the I0 Bessel function.
        //
        //  Discussion:
        //
        //    The modified Bessel functions In(Z) and Kn(Z) are solutions of
        //    the differential equation
        //
        //      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
        //
        //    The modified Bessel function I0(Z) corresponds to N = 0.
        //
        //    In Mathematica, the function can be evaluated by:
        //
        //      BesselI[0,x]
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    20 August 2004
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Milton Abramowitz, Irene Stegun,
        //    Handbook of Mathematical Functions,
        //    National Bureau of Standards, 1964,
        //    ISBN: 0-486-61272-4,
        //    LC: QA47.A34.
        //
        //    Stephen Wolfram,
        //    The Mathematica Book,
        //    Fourth Edition,
        //    Cambridge University Press, 1999,
        //    ISBN: 0-521-64314-7,
        //    LC: QA76.95.W65.
        //
        //  Parameters:
        //
        //    Input/output, int &N_DATA.  The user sets N_DATA to 0 before the
        //    first call.  On each call, the routine increments N_DATA by 1, and
        //    returns the corresponding data; when there is no more data, the
        //    output value of N_DATA will be 0 again.
        //
        //    Output, double &X, the argument of the function.
        //
        //    Output, double &FX, the value of the function.
        //
    {
        const int N_MAX = 20;

        double[] fx_vec =
        {
            0.1000000000000000E+01,
            0.1010025027795146E+01,
            0.1040401782229341E+01,
            0.1092045364317340E+01,
            0.1166514922869803E+01,
            0.1266065877752008E+01,
            0.1393725584134064E+01,
            0.1553395099731217E+01,
            0.1749980639738909E+01,
            0.1989559356618051E+01,
            0.2279585302336067E+01,
            0.3289839144050123E+01,
            0.4880792585865024E+01,
            0.7378203432225480E+01,
            0.1130192195213633E+02,
            0.1748117185560928E+02,
            0.2723987182360445E+02,
            0.6723440697647798E+02,
            0.4275641157218048E+03,
            0.2815716628466254E+04
        };

        double[] x_vec =
        {
            0.00E+00,
            0.20E+00,
            0.40E+00,
            0.60E+00,
            0.80E+00,
            0.10E+01,
            0.12E+01,
            0.14E+01,
            0.16E+01,
            0.18E+01,
            0.20E+01,
            0.25E+01,
            0.30E+01,
            0.35E+01,
            0.40E+01,
            0.45E+01,
            0.50E+01,
            0.60E+01,
            0.80E+01,
            0.10E+02
        };

        n_data = n_data switch
        {
            < 0 => 0,
            _ => n_data
        };

        n_data += 1;

        if (N_MAX < n_data)
        {
            n_data = 0;
            x = 0.0;
            fx = 0.0;
        }
        else
        {
            x = x_vec[n_data - 1];
            fx = fx_vec[n_data - 1];
        }
    }

    public static double bessel_i1(double arg)
        //****************************************************************************80
        //
        //  Purpose:
        //
        //    BESSEL_I1 evaluates the Bessel I function of order I.
        //
        //  Discussion:
        //
        //    The main computation evaluates slightly modified forms of
        //    minimax approximations generated by Blair and Edwards.
        //    This transportable program is patterned after the machine-dependent
        //    FUNPACK packet NATSI1, but cannot match that version for efficiency
        //    or accuracy.  This version uses rational functions that theoretically
        //    approximate I-SUB-1(X) to at least 18 significant decimal digits.
        //    The accuracy achieved depends on the arithmetic system, the compiler,
        //    the intrinsic functions, and proper selection of the machine-dependent
        //    constants.
        //
        //  Machine-dependent constants:
        //
        //    beta   = Radix for the floating-point system.
        //    maxexp = Smallest power of beta that overflows.
        //    XMAX =   Largest argument acceptable to BESI1;  Solution to
        //             equation:
        //               EXP(X) * (1-3/(8*X)) / SQRT(2*PI*X) = beta^maxexp
        //
        //
        //    Approximate values for some important machines are:
        //
        //                            beta       maxexp    XMAX
        //
        //    CRAY-1        (S.P.)       2         8191    5682.810
        //    Cyber 180/855
        //      under NOS   (S.P.)       2         1070     745.894
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (S.P.)       2          128      91.906
        //    IEEE (IBM/XT,
        //      SUN, etc.)  (D.P.)       2         1024     713.987
        //    IBM 3033      (D.P.)      16           63     178.185
        //    VAX           (S.P.)       2          127      91.209
        //    VAX D-Format  (D.P.)       2          127      91.209
        //    VAX G-Format  (D.P.)       2         1023     713.293
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    28 October 2004
        //
        //  Author:
        //
        //    Original FORTRAN77 version by William Cody, Laura Stoltz,
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Blair, Edwards,
        //    Chalk River Report AECL-4928,
        //    Atomic Energy of Canada, Limited,
        //    October, 1974.
        //
        //  Parameters:
        //
        //    Input, double ARG, the argument.
        //
        //    Output, double BESSEL_I1, the value of the Bessel
        //    I1 function.
        //
    {
        const double exp40 = 2.353852668370199854E+17;
        const double forty = 40.0;
        const double half = 0.5;
        const double one = 1.0;
        const double one5 = 15.0;
        double[] p =  {
            -1.9705291802535139930E-19,
            -6.5245515583151902910E-16,
            -1.1928788903603238754E-12,
            -1.4831904935994647675E-09,
            -1.3466829827635152875E-06,
            -9.1746443287817501309E-04,
            -4.7207090827310162436E-01,
            -1.8225946631657315931E+02,
            -5.1894091982308017540E+04,
            -1.0588550724769347106E+07,
            -1.4828267606612366099E+09,
            -1.3357437682275493024E+11,
            -6.9876779648010090070E+12,
            -1.7732037840791591320E+14,
            -1.4577180278143463643E+15
        };
        const double pbar = 3.98437500E-01;
        double[] pp =  {
            -6.0437159056137600000E-02,
            4.5748122901933459000E-01,
            -4.2843766903304806403E-01,
            9.7356000150886612134E-02,
            -3.2457723974465568321E-03,
            -3.6395264712121795296E-04,
            1.6258661867440836395E-05,
            -3.6347578404608223492E-07
        };
        double[] q =  {
            -4.0076864679904189921E+03,
            7.4810580356655069138E+06,
            -8.0059518998619764991E+09,
            4.8544714258273622913E+12,
            -1.3218168307321442305E+15
        };
        double[] qq =  {
            -3.8806586721556593450,
            3.2593714889036996297,
            -8.5017476463217924408E-01,
            7.4212010813186530069E-02,
            -2.2835624489492512649E-03,
            3.7510433111922824643E-05
        };
        const double rec15 = 6.6666666666666666666E-02;
        const double two25 = 225.0;
        double value;
        const double xmax = 713.987;
        const double zero = 0.0;

        double x = Math.Abs(arg);
        //
        //  ABS(ARG) < EPSILON ( ARG )
        //
        if (x < typeMethods.r8_epsilon())
        {
            value = half * x;
        }
        else
        {
            double sump;
            double sumq;
            double xx;
            switch (x)
            {
                //
                //  EPSILON ( ARG ) <= ABS(ARG) < 15.0
                //
                case < one5:
                {
                    xx = x * x;
                    sump = p[0];
                    int j;
                    for (j = 1; j < 15; j++)
                    {
                        sump = sump * xx + p[j];
                    }

                    xx -= two25;

                    sumq = ((((
                                        xx + q[0]
                                    ) * xx + q[1]
                                ) * xx + q[2]
                            ) * xx + q[3]
                        ) * xx + q[4];

                    value = sump / sumq * x;
                    break;
                }
                case > xmax:
                    value = typeMethods.r8_huge();
                    break;
                //
                default:
                {
                    xx = one / x - rec15;

                    sump = ((((((
                                                pp[0]
                                                * xx + pp[1]
                                            ) * xx + pp[2]
                                        ) * xx + pp[3]
                                    ) * xx + pp[4]
                                ) * xx + pp[5]
                            ) * xx + pp[6]
                        ) * xx + pp[7];

                    sumq = (((((
                                            xx + qq[0]
                                        ) * xx + qq[1]
                                    ) * xx + qq[2]
                                ) * xx + qq[3]
                            ) * xx + qq[4]
                        ) * xx + qq[5];

                    value = sump / sumq;

                    double a;
                    double b;
                    if (xmax - one5 < x)
                    {
                        a = Math.Exp(x - forty);
                        b = exp40;
                    }
                    else
                    {
                        a = Math.Exp(x);
                        b = one;
                    }

                    value = (value * a + pbar * a) / Math.Sqrt(x) * b;
                    break;
                }
            }
        }

        if (arg < zero)
        {
            value = -value;
        }

        return value;
    }

    public static void bessel_i1_values(ref int n_data, ref double x, ref double fx )
        //****************************************************************************80
        //
        //  Purpose:
        //
        //    BESSEL_I1_VALUES returns some values of the I1 Bessel function.
        //
        //  Discussion:
        //
        //    The modified Bessel functions In(Z) and Kn(Z) are solutions of
        //    the differential equation
        //
        //      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
        //
        //    In Mathematica, the function can be evaluated by:
        //
        //      BesselI[1,x]
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    20 August 2004
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Milton Abramowitz, Irene Stegun,
        //    Handbook of Mathematical Functions,
        //    National Bureau of Standards, 1964,
        //    ISBN: 0-486-61272-4,
        //    LC: QA47.A34.
        //
        //    Stephen Wolfram,
        //    The Mathematica Book,
        //    Fourth Edition,
        //    Cambridge University Press, 1999,
        //    ISBN: 0-521-64314-7,
        //    LC: QA76.95.W65.
        //
        //  Parameters:
        //
        //    Input/output, int &N_DATA.  The user sets N_DATA to 0 before the
        //    first call.  On each call, the routine increments N_DATA by 1, and
        //    returns the corresponding data; when there is no more data, the
        //    output value of N_DATA will be 0 again.
        //
        //    Output, double &X, the argument of the function.
        //
        //    Output, double &FX, the value of the function.
        //
    {
        const int N_MAX = 20;

        double[] fx_vec =
        {
            0.0000000000000000E+00,
            0.1005008340281251E+00,
            0.2040267557335706E+00,
            0.3137040256049221E+00,
            0.4328648026206398E+00,
            0.5651591039924850E+00,
            0.7146779415526431E+00,
            0.8860919814143274E+00,
            0.1084810635129880E+01,
            0.1317167230391899E+01,
            0.1590636854637329E+01,
            0.2516716245288698E+01,
            0.3953370217402609E+01,
            0.6205834922258365E+01,
            0.9759465153704450E+01,
            0.1538922275373592E+02,
            0.2433564214245053E+02,
            0.6134193677764024E+02,
            0.3998731367825601E+03,
            0.2670988303701255E+04
        };

        double[] x_vec =
        {
            0.00E+00,
            0.20E+00,
            0.40E+00,
            0.60E+00,
            0.80E+00,
            0.10E+01,
            0.12E+01,
            0.14E+01,
            0.16E+01,
            0.18E+01,
            0.20E+01,
            0.25E+01,
            0.30E+01,
            0.35E+01,
            0.40E+01,
            0.45E+01,
            0.50E+01,
            0.60E+01,
            0.80E+01,
            0.10E+02
        };

        n_data = n_data switch
        {
            < 0 => 0,
            _ => n_data
        };

        n_data += 1;

        if (N_MAX < n_data)
        {
            n_data = 0;
            x = 0.0;
            fx = 0.0;
        }
        else
        {
            x = x_vec[n_data - 1];
            fx = fx_vec[n_data - 1];
        }
    }

    public static void bessel_ix_values(ref int n_data, ref double nu, ref double x, ref double fx )
        //****************************************************************************80
        //
        //  Purpose:
        //
        //    BESSEL_IX_VALUES returns some values of the Ix Bessel function.
        //
        //  Discussion:
        //
        //    This set of data considers the less common case in which the
        //    index of the Bessel function In is actually not an integer.
        //    We may suggest this case by occasionally replacing the symbol
        //    "In" by "Ix".
        //
        //    The modified Bessel functions In(Z) and Kn(Z) are solutions of
        //    the differential equation
        //
        //      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
        //
        //    In Mathematica, the function can be evaluated by:
        //
        //      BesselI[n,x]
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    02 March 2007
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Milton Abramowitz, Irene Stegun,
        //    Handbook of Mathematical Functions,
        //    National Bureau of Standards, 1964,
        //    ISBN: 0-486-61272-4,
        //    LC: QA47.A34.
        //
        //    Stephen Wolfram,
        //    The Mathematica Book,
        //    Fourth Edition,
        //    Cambridge University Press, 1999,
        //    ISBN: 0-521-64314-7,
        //    LC: QA76.95.W65.
        //
        //  Parameters:
        //
        //    Input/output, int &N_DATA.  The user sets N_DATA to 0 before the
        //    first call.  On each call, the routine increments N_DATA by 1, and
        //    returns the corresponding data; when there is no more data, the
        //    output value of N_DATA will be 0 again.
        //
        //    Output, double &NU, the order of the function.
        //
        //    Output, double &X, the argument of the function.
        //
        //    Output, double &FX, the value of the function.
        //
    {
        const int N_MAX = 28;

        double[] fx_vec =
        {
            0.3592084175833614E+00,
            0.9376748882454876E+00,
            2.046236863089055E+00,
            3.053093538196718E+00,
            4.614822903407601E+00,
            26.47754749755907E+00,
            2778.784603874571E+00,
            4.327974627242893E+07,
            0.2935253263474798E+00,
            1.099473188633110E+00,
            21.18444226479414E+00,
            2500.906154942118E+00,
            2.866653715931464E+20,
            0.05709890920304825E+00,
            0.3970270801393905E+00,
            13.76688213868258E+00,
            2028.512757391936E+00,
            2.753157630035402E+20,
            0.4139416015642352E+00,
            1.340196758982897E+00,
            22.85715510364670E+00,
            2593.006763432002E+00,
            2.886630075077766E+20,
            0.03590910483251082E+00,
            0.2931108636266483E+00,
            11.99397010023068E+00,
            1894.575731562383E+00,
            2.716911375760483E+20
        };

        double[] nu_vec =
        {
            0.50E+00,
            0.50E+00,
            0.50E+00,
            0.50E+00,
            0.50E+00,
            0.50E+00,
            0.50E+00,
            0.50E+00,
            1.50E+00,
            1.50E+00,
            1.50E+00,
            1.50E+00,
            1.50E+00,
            2.50E+00,
            2.50E+00,
            2.50E+00,
            2.50E+00,
            2.50E+00,
            1.25E+00,
            1.25E+00,
            1.25E+00,
            1.25E+00,
            1.25E+00,
            2.75E+00,
            2.75E+00,
            2.75E+00,
            2.75E+00,
            2.75E+00
        };

        double[] x_vec =
        {
            0.2E+00,
            1.0E+00,
            2.0E+00,
            2.5E+00,
            3.0E+00,
            5.0E+00,
            10.0E+00,
            20.0E+00,
            1.0E+00,
            2.0E+00,
            5.0E+00,
            10.0E+00,
            50.0E+00,
            1.0E+00,
            2.0E+00,
            5.0E+00,
            10.0E+00,
            50.0E+00,
            1.0E+00,
            2.0E+00,
            5.0E+00,
            10.0E+00,
            50.0E+00,
            1.0E+00,
            2.0E+00,
            5.0E+00,
            10.0E+00,
            50.0E+00
        };

        n_data = n_data switch
        {
            < 0 => 0,
            _ => n_data
        };

        n_data += 1;

        if (N_MAX < n_data)
        {
            n_data = 0;
            nu = 0.0;
            x = 0.0;
            fx = 0.0;
        }
        else
        {
            nu = nu_vec[n_data - 1];
            x = x_vec[n_data - 1];
            fx = fx_vec[n_data - 1];
        }
    }

}