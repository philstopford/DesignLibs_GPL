using System;

namespace Burkardt.Sequence
{
    public static class VanDerCorput
    {
        public static double i4_to_van_der_corput(int seed, int base_)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    I4_TO_VAN_DER_CORPUT computes an element of a van der Corput sequence.
            //
            //  Discussion:
            //
            //    The van der Corput sequence is often used to generate a "subrandom"
            //    sequence of points which have a better covering property
            //    than pseudorandom points.
            //
            //    The van der Corput sequence generates a sequence of points in [0,1]
            //    which (theoretically) never repeats.  Except for SEED = 0, the
            //    elements of the van der Corput sequence are strictly between 0 and 1.
            //
            //    The van der Corput sequence writes an integer in a given base B,
            //    and then its digits are "reflected" about the decimal point.
            //    This maps the numbers from 1 to N into a set of numbers in [0,1],
            //    which are especially nicely distributed if N is one less
            //    than a power of the base.
            //
            //    Hammersley suggested generating a set of N nicely distributed
            //    points in two dimensions by setting the first component of the
            //    Ith point to I/N, and the second to the van der Corput 
            //    value of I in base 2.  
            //
            //    Halton suggested that in many cases, you might not know the number 
            //    of points you were generating, so Hammersley's formulation was
            //    not ideal.  Instead, he suggested that to generated a nicely
            //    distributed sequence of points in M dimensions, you simply
            //    choose the first M primes, P(1:M), and then for the J-th component of
            //    the I-th point in the sequence, you compute the van der Corput
            //    value of I in base P(J).
            //
            //    Thus, to generate a Halton sequence in a 2 dimensional space,
            //    it is typical practice to generate a pair of van der Corput sequences,
            //    the first with prime base 2, the second with prime base 3.
            //    Similarly, by using the first K primes, a suitable sequence
            //    in K-dimensional space can be generated.
            //
            //    The generation is quite simple.  Given an integer SEED, the expansion
            //    of SEED in base BASE is generated.  Then, essentially, the result R
            //    is generated by writing a decimal point followed by the digits of
            //    the expansion of SEED, in reverse order.  This decimal value is actually
            //    still in base BASE, so it must be properly interpreted to generate
            //    a usable value.
            //
            //  Example:
            //
            //    BASE = 2
            //
            //    SEED     SEED      van der Corput
            //    decimal  binary    binary   decimal
            //    -------  ------    ------   -------
            //        0  =     0  =>  .0     = 0.0
            //        1  =     1  =>  .1     = 0.5
            //        2  =    10  =>  .01    = 0.25
            //        3  =    11  =>  .11    = 0.75
            //        4  =   100  =>  .001   = 0.125
            //        5  =   101  =>  .101   = 0.625
            //        6  =   110  =>  .011   = 0.375
            //        7  =   111  =>  .111   = 0.875
            //        8  =  1000  =>  .0001  = 0.0625
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    25 February 2003
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    John Halton,
            //    On the efficiency of certain quasi-random sequences of points
            //    in evaluating multi-dimensional integrals,
            //    Numerische Mathematik,
            //    Volume 2, 1960, pages 84-90.
            // 
            //    John Hammersley,
            //    Monte Carlo methods for solving multivariable problems,
            //    Proceedings of the New York Academy of Science,
            //    Volume 86, 1960, pages 844-874.
            //
            //    Johannes van der Corput,
            //    Verteilungsfunktionen I & II,
            //    Nederl. Akad. Wetensch. Proc.,
            //    Volume 38, 1935, pages 813-820, pages 1058-1066.
            //
            //  Parameters:
            //
            //    Input, int SEED, the index of the desired element.
            //    SEED should be nonnegative.
            //    SEED = 0 is allowed, and returns R = 0.
            //
            //    Input, int BASE, the van der Corput base, which is usually 
            //    a prime number.  BASE must be greater than 1.
            //
            //    Output, double VAN_DER_CORPUT, the SEED-th element of the van 
            //    der Corput sequence for base BASE.
            //
        {
            double base_inv;
            int digit;
            double r;

            if (base_ <= 1)
            {
                Console.WriteLine("");
                Console.WriteLine("I4_TO_VAN_DER_CORPUT - Fatal error!");
                Console.WriteLine("  The input base BASE is <= 1!");
                Console.WriteLine("  BASE = " + base_ + "");
                return (1);
            }

            if (seed < 0)
            {
                Console.WriteLine("");
                Console.WriteLine("I4_TO_VAN_DER_CORPUT - Fatal error!");
                Console.WriteLine("  SEED < 0."+
                "  SEED = " + seed + "");
                return (1);
            }

            r = 0.0;

            base_inv = 1.0 / ((double)base_);

            while (seed != 0)
            {
                digit = seed % base_;
                r = r + ((double)digit) * base_inv;
                base_inv = base_inv / ((double)base_);
                seed = seed / base_;
            }

            return r;
        }
    }
}