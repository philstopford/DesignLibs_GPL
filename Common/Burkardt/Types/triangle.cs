using System;
using System.Collections.Generic;
using System.IO;
using Burkardt.LineNS;
using Burkardt.Uniform;

namespace Burkardt.Types
{
    public static partial class typeMethods
    {
        public static void subtriangle_next(int n, ref bool more, ref int i1, ref int j1, ref int i2, ref int j2,
                ref int i3, ref int j3)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    SUBTRIANGLE_NEXT computes the next subtriangle of a triangle.
            //
            //  Discussion:
            //
            //    The three sides of a triangle have been subdivided into N segments,
            //    inducing a natural subdivision of the triangle into N*N subtriangles.
            //    It is desired to consider each subtriangle, one at a time, in some
            //    definite order.  This routine can produce information defining each 
            //    of the subtriangles, one after another.
            //
            //    The subtriangles are described in terms of the integer coordinates 
            //    (I,J) of their vertices.  These coordinates both range from 0 to N,
            //    with the additional restriction that I + J <= N.
            //
            //    The vertices of each triangle are listed in counterclockwise order.
            //
            //  Example:
            //
            //    N = 4
            //
            //    4  *
            //       ||            
            //       16| 
            //    3  *--*
            //       |14|| 
            //       13\15| 
            //    2  *--*--*
            //       |\9|11|| 
            //       |8\10\12| 
            //    1  *--*--*--*
            //       |\2|\4|\6|| 
            //       |1\|3\|5\|7| 
            //   0   *--*--*--*--*
            //
            //       0  1  2  3  4
            //
            //    Rank  I1 J1  I2 J2  I3 J3
            //    ----  -----  -----  ----- 
            //       1   0  0   1  0   0  1
            //       2   1  1   0  1   1  0
            //       3   1  0   2  0   1  1
            //       4   2  1   1  1   2  0
            //       5   2  0   3  0   2  1
            //       6   3  1   1  1   3  0
            //       7   3  0   4  0   3  1
            //       8   0  1   1  1   0  2
            //       9   1  2   0  2   1  1
            //      10   1  1   2  1   1  2
            //      11   2  2   1  2   2  1
            //      12   2  1   3  1   2  2
            //      13   0  2   1  2   0  3
            //      14   1  3   0  3   1  2
            //      15   1  2   2  2   1  3
            //      16   0  3   1  3   0  4
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    27 March 2007
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int N, indicates the number of subdivisions of each side
            //    of the original triangle.
            //
            //    Input/output, bool &MORE.
            //    On first call, set MORE to FALSE.  Thereafter, the output value of MORE
            //    will be TRUE if there are more subtriangles that can be generated by
            //    further calls.  However, if MORE is returned as FALSE, the accompanying
            //    subtriangle information refers to the last subtriangle that can be
            //    generated.
            //
            //    Input/output, int &I1, &J1, &I2, &J2, &I3, &J3, the indices of the 
            //    vertices of the subtriangle.
            //
        {
            if (n <= 0)
            {
                more = false;
                return;
            }

            if (!more)
            {
                i1 = 0;
                j1 = 0;
                i2 = 1;
                j2 = 0;
                i3 = 0;
                j3 = 1;

                if (n == 1)
                {
                    more = false;
                }
                else
                {
                    more = true;
                }
            }
            //
            //  We last generated a triangle like:
            //
            //    2---1
            //     \  |
            //      \ |
            //       \|
            //        3
            //
            else if (i2 < i3)
            {
                i1 = i3;
                j1 = j3;
                i2 = i1 + 1;
                j2 = j1;
                i3 = i1;
                j3 = j1 + 1;
            }
            //
            //  We last generated a triangle like
            //
            //    3
            //    ||
            //    | |
            //    |  |
            //    1---2
            //
            else if (i1 + 1 + j1 + 1 <= n)
            {
                i1 = i1 + 1;
                j1 = j1 + 1;
                i2 = i1 - 1;
                j2 = j1;
                i3 = i1;
                j3 = j1 - 1;
            }
            //
            //  We must be at the end of a row.
            //
            else
            {
                i1 = 0;
                j1 = j1 + 1;
                i2 = i1 + 1;
                j2 = j1;
                i3 = i1;
                j3 = j1 + 1;

                if (n <= j1 + 1)
                {
                    more = false;
                }
            }
        }

        public static void triangle_angles_2d(double[] t, double[] angle)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ANGLES_2D computes the angles of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The law of cosines is used:
            //
            //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
            //
            //    where GAMMA is the angle opposite side C.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    30 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double ANGLE[3], the angles opposite
            //    sides P1-P2, P2-P3 and P3-P1, in radians.
            //
        {
            double a;
            double b;
            double c;
            

            a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                          + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));

            b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                          + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));

            c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                          + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
            //
            //  Take care of a ridiculous special case.
            //
            if (a == 0.0 && b == 0.0 && c == 0.0)
            {
                angle[0] = 2.0 * Math.PI / 3.0;
                angle[1] = 2.0 * Math.PI / 3.0;
                angle[2] = 2.0 * Math.PI / 3.0;
                return;
            }

            if (c == 0.0 || a == 0.0)
            {
                angle[0] = Math.PI;
            }
            else
            {
                angle[0] = r8_acos((c * c + a * a - b * b) / (2.0 * c * a));
            }

            if (a == 0.0 || b == 0.0)
            {
                angle[1] = Math.PI;
            }
            else
            {
                angle[1] = r8_acos((a * a + b * b - c * c) / (2.0 * a * b));
            }

            if (b == 0.0 || c == 0.0)
            {
                angle[2] = Math.PI;
            }
            else
            {
                angle[2] = r8_acos((b * b + c * c - a * a) / (2.0 * b * c));
            }
        }

        public static void triangle_reference_sample(int n, ref int seed, ref double[] p)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_REFERENCE_SAMPLE returns random points in the reference triangle.
            //
            //  Diagram:
            //
            //       3
            //    s  |.
            //    i  | .
            //    d  |  .
            //    e  |   .  side 2
            //       |    .
            //    3  |     .
            //       |      .
            //       1-------2
            //
            //         side 1
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    07 December 2006
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, integer N, the number of points to sample.
            //
            //    Input/output, int *SEED, a seed for the random number generator.
            //
            //    Output, double P[2*N], a random point in the triangle.
            //
        {
            int DIM_NUM = 2;

            double alpha;
            double beta;
            int j;
            double r;

            p = new double[n * 2];

            for (j = 0; j < n; j++)
            {
                r = UniformRNG.r8_uniform_01(ref seed);
                //
                //  Interpret R as a percentage of the triangle's area.
                //
                //  Imagine a line L, parallel to side 1, so that the area between
                //  vertex 1 and line L is R percent of the full triangle's area.
                //
                //  The line L will intersect sides 2 and 3 at a fraction
                //  ALPHA = SQRT ( R ) of the distance from vertex 1 to vertices 2 and 3.
                //
                alpha = Math.Sqrt(r);
                //
                //  Now choose, uniformly at random, a point on the line L.
                //
                beta = UniformRNG.r8_uniform_01(ref seed);

                p[(0 + j * 2) % p.Length] = (1.0 - beta) * alpha;
                p[(1 + j * 2) % p.Length] = beta * alpha;
            }
        }

        public static void triangle_sample(double[] t, int n, ref int seed, ref double[] p, int pIndex = 0)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_SAMPLE returns random points in a triangle.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    06 December 2006
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Input, integer N, the number of points to sample.
            //
            //    Input/output, int *SEED, a seed for the random number generator.
            //
            //    Output, double P[2*N], a random point in the triangle.
            //
        {
            int DIM_NUM = 2;

            double alpha;
            double beta;
            int j;
            double r;
            double[] p12 = new double[DIM_NUM];
            double[] p13 = new double[DIM_NUM];

            p = new double[2 * n];

            for (j = 0; j < n; j++)
            {
                r = UniformRNG.r8_uniform_01(ref seed);
                //
                //  Interpret R as a percentage of the triangle's area.
                //
                //  Imagine a line L, parallel to side 1, so that the area between
                //  vertex 1 and line L is R percent of the full triangle's area.
                //
                //  The line L will intersect sides 2 and 3 at a fraction
                //  ALPHA = SQRT ( R ) of the distance from vertex 1 to vertices 2 and 3.
                //
                alpha = Math.Sqrt(r);
                //
                //  Determine the coordinates of the points on sides 2 and 3 intersected
                //  by line L.
                //
                p12[0] = (1.0 - alpha) * t[0 + 0 * 2] + alpha * t[0 + 1 * 2];
                p12[1] = (1.0 - alpha) * t[1 + 0 * 2] + alpha * t[1 + 1 * 2];

                p13[0] = (1.0 - alpha) * t[0 + 0 * 2] + alpha * t[0 + 2 * 2];
                ;
                p13[1] = (1.0 - alpha) * t[1 + 0 * 2] + alpha * t[1 + 2 * 2];
                ;
                //
                //  Now choose, uniformly at random, a point on the line L.
                //
                beta = UniformRNG.r8_uniform_01(ref seed);

                p[(pIndex + (0 + j * 2) + p.Length) % p.Length] = (1.0 - beta) * p12[0] + beta * p13[0];
                p[(pIndex + (1 + j * 2) + p.Length) % p.Length] = (1.0 - beta) * p12[1] + beta * p13[1];
            }
        }

        public static double[] triangle_angles_2d_new(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ANGLES_2D_NEW computes the angles of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The law of cosines is used:
            //
            //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
            //
            //    where GAMMA is the angle opposite side C.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    30 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double ANGLE[3], the angles opposite
            //    sides P1-P2, P2-P3 and P3-P1, in radians.
            //
        {
            double[] angle;
            double a;
            double b;
            double c;
            

            angle = new double[3];

            a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                          + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));

            b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                          + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));

            c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                          + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
            //
            //  Take care of a ridiculous special case.
            //
            if (a == 0.0 && b == 0.0 && c == 0.0)
            {
                angle[0] = 2.0 * Math.PI / 3.0;
                angle[1] = 2.0 * Math.PI / 3.0;
                angle[2] = 2.0 * Math.PI / 3.0;
                return angle;
            }

            if (c == 0.0 || a == 0.0)
            {
                angle[0] = Math.PI;
            }
            else
            {
                angle[0] = Helpers.arc_cosine((c * c + a * a - b * b) / (2.0 * c * a));
            }

            if (a == 0.0 || b == 0.0)
            {
                angle[1] = Math.PI;
            }
            else
            {
                angle[1] = Helpers.arc_cosine((a * a + b * b - c * c) / (2.0 * a * b));
            }

            if (b == 0.0 || c == 0.0)
            {
                angle[2] = Math.PI;
            }
            else
            {
                angle[2] = Helpers.arc_cosine((b * b + c * c - a * a) / (2.0 * b * c));
            }

            return angle;
        }

        public static double triangle_area_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_AREA_2D computes the area of a triangle in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    03 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the vertices of the triangle.
            //
            //    Output, double TRIANGLE_AREA_2D, the area of the triangle.  AREA will
            //    be nonnegative.
            //
        {
            double area = (0.5 * (
                t[0 + 0 * 2] * (t[1 + 2 * 2] - t[1 + 1 * 2]) +
                t[0 + 1 * 2] * (t[1 + 0 * 2] - t[1 + 2 * 2]) +
                t[0 + 2 * 2] * (t[1 + 1 * 2] - t[1 + 0 * 2])));

            return area;
        }

        public static double[] triangle_centroid_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_CENTROID_2D computes the centroid of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The centroid of a triangle can also be considered the center
            //    of gravity, assuming that the triangle is made of a thin uniform
            //    sheet of massy material.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    03 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    Adrian Bowyer, John Woodwark,
            //    A Programmer's Geometry,
            //    Butterworths, 1983.
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the vertices of the triangle.
            //
            //    Output, double TRIANGLE_CENTROID_2D[2], the coordinates of the centroid of the triangle.
            //
        {
            double[] centroid;

            centroid = new double[2];

            centroid[0] = (t[0 + 0 * 2] + t[0 + 1 * 2] + t[0 + 2 * 2]) / 3.0;
            centroid[1] = (t[1 + 0 * 2] + t[1 + 1 * 2] + t[1 + 2 * 2]) / 3.0;

            return centroid;
        }

        public static double[] triangle_circumcenter_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_CIRCUMCENTER_2D computes the circumcenter of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The circumcenter of a triangle is the center of the circumcircle, the
            //    circle that passes through the three vertices of the triangle.
            //
            //    The circumcircle contains the triangle, but it is not necessarily the
            //    smallest triangle to do so.
            //
            //    If all angles of the triangle are no greater than 90 degrees, then
            //    the center of the circumscribed circle will lie inside the triangle.
            //    Otherwise, the center will lie outside the triangle.
            //
            //    The circumcenter is the intersection of the perpendicular bisectors
            //    of the sides of the triangle.
            //
            //    In geometry, the circumcenter of a triangle is often symbolized by "O".
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    09 February 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double *TRIANGLE_CIRCUMCENTER_2D[2], the circumcenter of
            //    the triangle.
            //
        {
            int DIM_NUM = 2;

            double asq;
            double bot;
            double[] center;
            double csq;
            double top1;
            double top2;

            center = new double[DIM_NUM];

            asq = (t[0 + 1 * 2] - t[0 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2])
                  + (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[1 + 1 * 2] - t[1 + 0 * 2]);

            csq = (t[0 + 2 * 2] - t[0 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
                  + (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[1 + 2 * 2] - t[1 + 0 * 2]);

            top1 = (t[1 + 1 * 2] - t[1 + 0 * 2]) * csq - (t[1 + 2 * 2] - t[1 + 0 * 2]) * asq;
            top2 = -(t[0 + 1 * 2] - t[0 + 0 * 2]) * csq + (t[0 + 2 * 2] - t[0 + 0 * 2]) * asq;

            bot = (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
                  - (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2]);

            center[0] = t[0 + 0 * 2] + 0.5 * top1 / bot;
            center[1] = t[1 + 0 * 2] + 0.5 * top2 / bot;

            return center;
        }

        public static void triangle_circumcircle_2d(double[] t, ref double r, ref double[] pc)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_CIRCUMCIRCLE_2D computes the circumcircle of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The circumcenter of a triangle is the center of the circumcircle, the
            //    circle that passes through the three vertices of the triangle.
            //
            //    The circumcircle contains the triangle, but it is not necessarily the
            //    smallest triangle to do so.
            //
            //    If all angles of the triangle are no greater than 90 degrees, then
            //    the center of the circumscribed circle will lie inside the triangle.
            //    Otherwise, the center will lie outside the triangle.
            //
            //    The circumcenter is the intersection of the perpendicular bisectors
            //    of the sides of the triangle.
            //
            //    In geometry, the circumcenter of a triangle is often symbolized by "O".
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    04 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double *R, PC[2], the circumradius, and the coordinates of the 
            //    circumcenter of the triangle.
            //
        {
            double a;
            double b;
            double bot;
            double c;
            double top1;
            double top2;
            //
            //  Circumradius.
            //
            a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2) + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
            b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2) + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
            c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2) + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));

            bot = (a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c);

            if (bot <= 0.0)
            {
                r = -1.0;
                pc[0] = 0.0;
                pc[1] = 0.0;
                return;
            }

            r = a * b * c / Math.Sqrt(bot);
            //
            //  Circumcenter.
            //
            top1 = (t[1 + 1 * 2] - t[1 + 0 * 2]) * c * c - (t[1 + 2 * 2] - t[1 + 0 * 2]) * a * a;
            top2 = (t[0 + 1 * 2] - t[0 + 0 * 2]) * c * c - (t[0 + 2 * 2] - t[0 + 0 * 2]) * a * a;
            bot = (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
                  - (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2]);

            pc[0] = t[0 + 0 * 2] + 0.5 * top1 / bot;
            pc[1] = t[1 + 0 * 2] - 0.5 * top2 / bot;

            return;
        }

        public static bool triangle_contains_point_2d(double[] t, double[] p)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_CONTAINS_POINT_2D finds if a point is inside a triangle in 2D.
            //
            //  Discussion:
            //
            //    The routine assumes that the vertices are given in counter clockwise
            //    order.  If the triangle vertices are actually given in clockwise
            //    order, this routine will behave as though the triangle contains
            //    no points whatsoever!
            //
            //    The routine determines if P is "to the right of" each of the lines
            //    that bound the triangle.  It does this by computing the cross product
            //    of vectors from a vertex to its next vertex, and to P.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    07 June 2006
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //    The vertices should be given in counter clockwise order.
            //
            //    Input, double P[2], the point to be checked.
            //
            //    Output, bool TRIANGLE_CONTAINS_POINT_2D, is TRUE if P is inside
            //    the triangle or on its boundary.
            //
        {
            int j;
            int k;

            for (j = 0; j < 3; j++)
            {
                k = (j + 1) % 3;
                if (0.0 < (p[0] - t[0 + j * 2]) * (t[1 + k * 2] - t[1 + j * 2])
                    - (p[1] - t[1 + j * 2]) * (t[0 + k * 2] - t[0 + j * 2]))
                {
                    return false;
                }
            }

            return true;
        }

        public static double triangle_diameter_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_DIAMETER computes the diameter of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The diameter of a triangle is the diameter of the smallest circle
            //    that can be drawn around the triangle.  At least two of the vertices
            //    of the triangle will intersect the circle, but not necessarily
            //    all three!
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    09 November 2015
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double TRIANGLE_DIAMETER, the diameter of the triangle.
            //
        {
            double a;
            double b;
            double c;
            double diam;
            double s;
            //
            //  Compute the (squares of) the lengths of the sides.
            //
            a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2) + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
            b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2) + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
            c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2) + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
            //
            //  Take care of a zero side.
            //
            if (a == 0.0)
            {
                return Math.Sqrt(b);
            }
            else if (b == 0.0)
            {
                return Math.Sqrt(c);
            }
            else if (c == 0.0)
            {
                return Math.Sqrt(a);
            }

            //
            //  Make A the largest.
            //
            if (a < b)
            {
                s = a;
                a = b;
                b = s;
            }

            if (a < c)
            {
                s = a;
                a = c;
                c = s;
            }

            //
            //  If A is very large...
            //
            if (b + c < a)
            {
                diam = Math.Sqrt(a);
            }
            else
            {
                a = Math.Sqrt(a);
                b = Math.Sqrt(b);
                c = Math.Sqrt(c);
                diam = 2.0 * a * b * c / Math.Sqrt((a + b + c) * (-a + b + c)
                                                               * (a - b + c) * (a + b - c));
            }

            return diam;
        }

        public static double[] triangle_edge_length_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_EDGE_LENGTH_2D returns edge lengths of a triangle in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    17 August 2009
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double TRIANGLE_EDGE_LENGTH[3], the length of the edges.
            //
        {
            double[] edge_length;
            int j1;
            int j2;

            edge_length = new double[3];

            for (j1 = 0; j1 < 3; j1++)
            {
                j2 = i4_wrap(j1 + 1, 0, 2);
                edge_length[j1] = Math.Sqrt(Math.Pow(t[0 + j2 * 2] - t[0 + j1 * 2], 2)
                                            + Math.Pow(t[1 + j2 * 2] - t[1 + j1 * 2], 2));
            }

            return edge_length;
        }

        public static void triangle_incircle_2d(double[] t, ref double[] pc, ref double r)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_INCIRCLE_2D computes the inscribed circle of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The inscribed circle of a triangle is the largest circle that can
            //    be drawn inside the triangle.  It is tangent to all three sides,
            //    and the lines from its center to the vertices bisect the angles
            //    made by each vertex.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    03 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    Adrian Bowyer, John Woodwark,
            //    A Programmer's Geometry,
            //    Butterworths, 1983.
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double PC[2], *R, the center of the inscribed circle, and its radius.
            //
        {
            double perim;
            double s12;
            double s23;
            double s31;

            s12 = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                            + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
            s23 = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                            + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
            s31 = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                            + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));

            perim = s12 + s23 + s31;

            if (perim == 0.0)
            {
                r = 0.0;
                pc[0] = t[0 + 0 * 2];
                pc[1] = t[1 + 0 * 2];
            }
            else
            {
                pc[0] = (s23 * t[0 + 0 * 2] + s31 * t[0 + 1 * 2] + s12 * t[0 + 2 * 2]) / perim;
                pc[1] = (s23 * t[1 + 0 * 2] + s31 * t[1 + 1 * 2] + s12 * t[1 + 2 * 2]) / perim;

                r = 0.5 * Math.Sqrt(
                    (-s12 + s23 + s31)
                    * (+s12 - s23 + s31)
                    * (+s12 + s23 - s31) / perim);
            }
        }

        public static int triangle_num ( int n )

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NUM returns the N-th triangular number.
            //
            //  Definition:
            //
            //    The N-th triangular number T(N) is formed by the sum of the first
            //    N ints:
            //
            //      T(N) = sum ( 1 <= I <= N ) I
            //
            //    By convention, T(0) = 0.
            //
            //  Formula:
            //
            //    T(N) = ( N * ( N + 1 ) ) / 2
            //
            //  First Values:
            //
            //     0
            //     1
            //     3
            //     6
            //    10
            //    15
            //    21
            //    28
            //    36
            //    45
            //    55
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    12 October 2012
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int N, the index of the desired number, 
            //    which must be at least 0.
            //
            //    Output, int TRIANGLE_NUM, the N-th triangular number.
            //
        {
            int value;

            value = ( n * ( n + 1 ) ) / 2;

            return value;
        }
        public static int triangle_orientation_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ORIENTATION_2D determines the orientation of a triangle in 2D.
            //
            //  Discussion:
            //
            //    Three distinct non-colinear points in the plane define a circle.
            //    If the points are visited in the order (x1,y1), (x2,y2), and then
            //    (x3,y3), this motion defines a clockwise or counter clockwise
            //    rotation along the circle.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    04 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, int TRIANGLE_ORIENTATION_2D, reports if the three points lie
            //    clockwise on the circle that passes through them.  The possible
            //    return values are:
            //    0, the points are distinct, noncolinear, and lie counter clockwise
            //    on their circle.
            //    1, the points are distinct, noncolinear, and lie clockwise
            //    on their circle.
            //    2, the points are distinct and colinear.
            //    3, at least two of the points are identical.
            //
        {
            double det;
            int value = 0;

            if (r8vec_eq(2, t, t, 0 * 2, 1 * 2) ||
                r8vec_eq(2, t, t, 1 * 2, 2 * 2) ||
                r8vec_eq(2, t, t, 2 * 2, 0 * 2))
            {
                value = 3;
                return value;
            }

            det = (t[0 + 0 * 2] - t[0 + 2 * 2]) * (t[1 + 1 * 2] - t[1 + 2 * 2])
                  - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (t[1 + 0 * 2] - t[1 + 2 * 2]);

            if (det == 0.0)
            {
                value = 2;
            }
            else if (det < 0.0)
            {
                value = 1;
            }
            else if (0.0 < det)
            {
                value = 0;
            }

            return value;
        }

        public static void triangle_orthocenter_2d(double[] t, double[] p, ref bool flag)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ORTHOCENTER_2D computes the orthocenter of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The orthocenter is defined as the intersection of the three altitudes
            //    of a triangle.
            //
            //    An altitude of a triangle is the line through a vertex of the triangle
            //    and perpendicular to the opposite side.
            //
            //    In geometry, the orthocenter of a triangle is often symbolized by "H".
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    30 July 2009
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    Adrian Bowyer, John Woodwark,
            //    A Programmer's Geometry,
            //    Butterworths, 1983.
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double P[2], the coordinates of the orthocenter of the triangle.
            //
            //    Output, bool *FLAG, is TRUE if the point could not be computed.
            //
        {
            int ival = 0;
            double[] p23;
            double[] p31;
            //
            //  Determine a point P23 common to the line through P2 and P3 and
            //  its perpendicular through P1.
            //
            p23 = Line.line_exp_perp_2d(t, t, t, ref flag, p1Index: 1 * 2, p2Index: 2 * 2, p3Index: 0 * 2);

            if (flag)
            {
                p[0] = r8_huge();
                p[1] = r8_huge();
                return;
            }

            //
            //  Determine a point P31 common to the line through P3 and P1 and
            //  its perpendicular through P2.
            //
            p31 = Line.line_exp_perp_2d(t, t, t, ref flag, p1Index: 2 * 2, p2Index: 0 * 2, p3Index: 1 * 2);
            if (flag)
            {
                p[0] = r8_huge();
                p[1] = r8_huge();
            }

            //
            //  Determine P, the intersection of the lines through P1 and P23, and
            //  through P2 and P31.
            //
            Line.lines_exp_int_2d(t, p23, t, p31, ref ival, ref p, p1Index: 0 * 2, p3Index: 1 * 2);

            if (ival != 1)
            {
                p[0] = r8_huge();
                p[1] = r8_huge();
                flag = true;
            }
        }

        public static double triangle_quality_2d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_QUALITY_2D: "quality" of a triangle in 2D.
            //
            //  Discussion:
            //
            //    The quality of a triangle is 2 times the ratio of the radius of the inscribed
            //    circle divided by that of the circumscribed circle.  An equilateral
            //    triangle achieves the maximum possible quality of 1.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    30 July 2009
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    Adrian Bowyer, John Woodwark,
            //    A Programmer's Geometry,
            //    Butterworths, 1983.
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Output, double TRIANGLE_QUALITY_2D, the quality of the triangle.
            //
        {
            double a;
            double b;
            double c;
            int i;
            double value;
            //
            //  Compute the length of each side.
            //
            a = 0.0;
            b = 0.0;
            c = 0.0;

            for (i = 0; i < 2; i++)
            {
                a = a + Math.Pow(t[i + 0 * 2] - t[i + 1 * 2], 2);
                b = b + Math.Pow(t[i + 1 * 2] - t[i + 2 * 2], 2);
                c = c + Math.Pow(t[i + 2 * 2] - t[i + 0 * 2], 2);
            }

            a = Math.Sqrt(a);
            b = Math.Sqrt(b);
            c = Math.Sqrt(c);

            if (a * b * c == 0.0)
            {
                value = 0.0;
            }
            else
            {
                value = (-a + b + c) * (a - b + c) * (a + b - c)
                        / (a * b * c);
            }

            return value;
        }

        public static double triangle_point_dist(double[] t, double[] p)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_POINT_DIST: distance ( triangle, point ) in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    01 June 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Input, double P[2], the point which is to be checked.
            //
            //    Output, double TRIANGLE_POINT_DIST, the distance from the point to the triangle.
            //    DIST is zero if the point lies exactly on the triangle.
            //
        {
            double value;

            value = Line.segment_point_dist(t, t, p, p1Index: +0 * 2, p2Index: +1 * 2);
            value = Math.Min(value, Line.segment_point_dist(t, t, p, p1Index: +1 * 2, p2Index: +2 * 2));
            value = Math.Min(value, Line.segment_point_dist(t, t, p, p1Index: +2 * 2, p2Index: +0 * 2));

            return value;
        }

        public static void triangle_point_near(double[] t, double[] p, ref double[] pn,
                ref double dist)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_POINT_NEAR computes the nearest triangle point to a point in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    01 June 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Input, double P[2], the point whose nearest neighbor
            //    on the line is to be determined.
            //
            //    Output, double PN[2], the nearest point to P.
            //
            //    Output, double &DIST, the distance from the point to the triangle.
            //
        {
            double dist12 = 0;
            double dist23 = 0;
            double dist31 = 0;
            double tval = 0;
            double[] pn12 = new double[2];
            double[] pn23 = new double[2];
            double[] pn31 = new double[2];
            //
            //  Find the distance to each of the line segments that make up the edges
            //  of the triangle.
            //
            Line.segment_point_near(t, t, p, ref pn12, ref dist12, ref tval, p1Index: +0 * 2, p2Index: +1 * 2);

            Line.segment_point_near(t, t, p, ref pn23, ref dist23, ref tval, p1Index: +1 * 2, p2Index: +2 * 2);

            Line.segment_point_near(t, t, p, ref pn31, ref dist31, ref tval, p1Index: +2 * 2, p2Index: +0 * 2);

            if (dist12 <= dist23 && dist12 <= dist31)
            {
                dist = dist12;
                r8vec_copy(2, pn12, ref pn);
            }
            else if (dist23 <= dist12 && dist23 <= dist31)
            {
                dist = dist23;
                r8vec_copy(2, pn23, ref pn);
            }
            else
            {
                dist = dist31;
                r8vec_copy(2, pn31, ref pn);
            }
        }

        public static void triangle_points_plot(string file_name, double[] node_xy, int node_show,
                int point_num, double[] point_xy, int point_show)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_POINTS_PLOT plots a triangle and some points.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    04 October 2006
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, char *FILE_NAME, the name of the output file.
            //
            //    Input, double NODE_XY[2*3], the coordinates of the nodes
            //    of the triangle.
            //
            //    Input, int NODE_SHOW,
            //   -1, do not show the triangle, or the nodes.
            //    0, show the triangle, do not show the nodes;
            //    1, show the triangle and the nodes;
            //    2, show the triangle, the nodes and number them.
            //
            //    Input, int POINT_NUM, the number of points.
            //
            //    Input, double POINT_XY[2*POINT_NUM], the coordinates of the 
            //    points.
            //
            //    Input, int POINT_SHOW,
            //    0, do not show the points;
            //    1, show the points;
            //    2, show the points and number them.
            //
        {
            int circle_size;
            int delta;
            List<string> file_unit = new List<string>();
            int i;
            int node;
            int node_num = 3;
            int point;
            double x_max;
            double x_min;
            int x_ps;
            int x_ps_max = 576;
            int x_ps_max_clip = 594;
            int x_ps_min = 36;
            int x_ps_min_clip = 18;
            double x_scale;
            double y_max;
            double y_min;
            int y_ps;
            int y_ps_max = 666;
            int y_ps_max_clip = 684;
            int y_ps_min = 126;
            int y_ps_min_clip = 108;
            double y_scale;
            //
            //  We need to do some figuring here, so that we can determine
            //  the range of the data, and hence the height and width
            //  of the piece of paper.
            //
            x_max = -r8_huge();
            for (node = 0; node < node_num; node++)
            {
                if (x_max < node_xy[0 + node * 2])
                {
                    x_max = node_xy[0 + node * 2];
                }
            }

            for (point = 0; point < point_num; point++)
            {
                if (x_max < point_xy[0 + point * 2])
                {
                    x_max = point_xy[0 + point * 2];
                }
            }

            x_min = r8_huge();
            for (node = 0; node < node_num; node++)
            {
                if (node_xy[0 + node * 2] < x_min)
                {
                    x_min = node_xy[0 + node * 2];
                }
            }

            for (point = 0; point < point_num; point++)
            {
                if (point_xy[0 + point * 2] < x_min)
                {
                    x_min = point_xy[0 + point * 2];
                }
            }

            x_scale = x_max - x_min;

            x_max = x_max + 0.05 * x_scale;
            x_min = x_min - 0.05 * x_scale;
            x_scale = x_max - x_min;

            y_max = -r8_huge();
            for (node = 0; node < node_num; node++)
            {
                if (y_max < node_xy[1 + node * 2])
                {
                    y_max = node_xy[1 + node * 2];
                }
            }

            for (point = 0; point < point_num; point++)
            {
                if (y_max < point_xy[1 + point * 2])
                {
                    y_max = point_xy[1 + point * 2];
                }
            }

            y_min = r8_huge();
            for (node = 0; node < node_num; node++)
            {
                if (node_xy[1 + node * 2] < y_min)
                {
                    y_min = node_xy[1 + node * 2];
                }
            }

            for (point = 0; point < point_num; point++)
            {
                if (point_xy[1 + point * 2] < y_min)
                {
                    y_min = point_xy[1 + point * 2];
                }
            }

            y_scale = y_max - y_min;

            y_max = y_max + 0.05 * y_scale;
            y_min = y_min - 0.05 * y_scale;
            y_scale = y_max - y_min;

            if (x_scale < y_scale)
            {
                delta = (int) r8_nint((double) (x_ps_max - x_ps_min)
                    * (y_scale - x_scale) / (2.0 * y_scale));

                x_ps_max = x_ps_max - delta;
                x_ps_min = x_ps_min + delta;

                x_ps_max_clip = x_ps_max_clip - delta;
                x_ps_min_clip = x_ps_min_clip + delta;

                x_scale = y_scale;
            }
            else if (y_scale < x_scale)
            {
                delta = (int) r8_nint((double) (y_ps_max - y_ps_min)
                    * (x_scale - y_scale) / (2.0 * x_scale));

                y_ps_max = y_ps_max - delta;
                y_ps_min = y_ps_min + delta;

                y_ps_max_clip = y_ps_max_clip - delta;
                y_ps_min_clip = y_ps_min_clip + delta;

                y_scale = x_scale;
            }

            file_unit.Add("%//PS-Adobe-3.0 EPSF-3.0");
            file_unit.Add("%%Creator: triangulation_order3_plot.C");
            file_unit.Add("%%Title: " + file_name + "");
            file_unit.Add("%%Pages: 1");
            file_unit.Add("%%BoundingBox:  "
                          + x_ps_min + "  "
                          + y_ps_min + "  "
                          + x_ps_max + "  "
                          + y_ps_max + "");
            file_unit.Add("%%Document-Fonts: Times-Roman");
            file_unit.Add("%%LanguageLevel: 1");
            file_unit.Add("%%EndComments");
            file_unit.Add("%%BeginProlog");
            file_unit.Add("/inch {72 mul} def");
            file_unit.Add("%%EndProlog");
            file_unit.Add("%%Page: 1 1");
            file_unit.Add("save");
            file_unit.Add("%");
            file_unit.Add("%  Set the RGB line color to very light gray.");
            file_unit.Add("%");
            file_unit.Add("0.900  0.900  0.900 setrgbcolor");
            file_unit.Add("%");
            file_unit.Add("%  Draw a gray border around the page.");
            file_unit.Add("%");
            file_unit.Add("newpath");
            file_unit.Add(x_ps_min + "  "
                                   + y_ps_min + "  moveto");
            file_unit.Add(x_ps_max + "  "
                                   + y_ps_min + "  lineto");
            file_unit.Add(x_ps_max + "  "
                                   + y_ps_max + "  lineto");
            file_unit.Add(x_ps_min + "  "
                                   + y_ps_max + "  lineto");
            file_unit.Add(x_ps_min + "  "
                                   + y_ps_min + "  lineto");
            file_unit.Add("stroke");
            file_unit.Add("%");
            file_unit.Add("%  Set the RGB color to black.");
            file_unit.Add("%");
            file_unit.Add("0.000  0.000  0.000 setrgbcolor");
            file_unit.Add("%");
            file_unit.Add("%  Set the font and its size.");
            file_unit.Add("%");
            file_unit.Add("/Times-Roman findfont");
            file_unit.Add("0.50 inch scalefont");
            file_unit.Add("setfont");
            file_unit.Add("%");
            file_unit.Add("%  Print a title.");
            file_unit.Add("%");
            file_unit.Add("%  210  702  moveto");
            file_unit.Add("%  (Triangulation)  show");
            file_unit.Add("%");
            file_unit.Add("%  Define a clipping polygon.");
            file_unit.Add("%");
            file_unit.Add("newpath");
            file_unit.Add(x_ps_min_clip + "  "
                                        + y_ps_min_clip + "  moveto");
            file_unit.Add(x_ps_max_clip + "  "
                                        + y_ps_min_clip + "  lineto");
            file_unit.Add(x_ps_max_clip + "  "
                                        + y_ps_max_clip + "  lineto");
            file_unit.Add(x_ps_min_clip + "  "
                                        + y_ps_max_clip + "  lineto");
            file_unit.Add(x_ps_min_clip + "  "
                                        + y_ps_min_clip + "  lineto");
            file_unit.Add("clip newpath");
            //
            //  Draw the triangle.
            //
            if (0 <= node_show)
            {
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to red.");
                file_unit.Add("%");
                file_unit.Add("0.900  0.200  0.100 setrgbcolor");
                file_unit.Add("%");
                file_unit.Add("%  Draw the triangle.");
                file_unit.Add("%");

                file_unit.Add("newpath");

                for (i = 0; i <= 3; i++)
                {
                    node = i4_wrap(i, 0, 2);

                    x_ps = (int) (
                        ((x_max - node_xy[0 + node * 2]) * (double) (x_ps_min)
                         + (node_xy[0 + node * 2] - x_min) * (double) (x_ps_max))
                        / (x_max - x_min));

                    y_ps = (int) (
                        ((y_max - node_xy[1 + node * 2]) * (double) (y_ps_min)
                         + (node_xy[1 + node * 2] - y_min) * (double) (y_ps_max))
                        / (y_max - y_min));

                    if (i == 0)
                    {
                        file_unit.Add(x_ps + "  " + y_ps + "  moveto");
                    }
                    else
                    {
                        file_unit.Add(x_ps + "  " + y_ps + "  lineto");
                    }
                }

                file_unit.Add("stroke");
            }

            //
            //  Draw the nodes.
            //
            if (1 <= node_show)
            {
                circle_size = 5;

                file_unit.Add("%");
                file_unit.Add("%  Draw filled dots at the nodes.");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to blue.");
                file_unit.Add("%");
                file_unit.Add("0.000  0.150  0.750 setrgbcolor");
                file_unit.Add("%");

                for (node = 0; node < 3; node++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - node_xy[0 + node * 2]) * (double) (x_ps_min)
                         + (node_xy[0 + node * 2] - x_min) * (double) (x_ps_max))
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - node_xy[1 + node * 2]) * (double) (y_ps_min)
                         + (node_xy[1 + node * 2] - y_min) * (double) (y_ps_max))
                        / (y_max - y_min));

                    file_unit.Add("newpath  " + x_ps
                                              + "  " + y_ps
                                              + "  " + circle_size
                                              + "  0 360 arc closepath fill");
                }
            }

            //
            //  Label the nodes.
            //
            if (2 <= node_show)
            {
                file_unit.Add("%");
                file_unit.Add("%  Label the nodes:");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to darker blue.");
                file_unit.Add("%");
                file_unit.Add("0.000  0.250  0.850 setrgbcolor");
                file_unit.Add("/Times-Roman findfont");
                file_unit.Add("0.20 inch scalefont");
                file_unit.Add("setfont");
                file_unit.Add("%");

                for (node = 0; node < node_num; node++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - node_xy[0 + node * 2]) * (double) (x_ps_min)
                         + (+node_xy[0 + node * 2] - x_min) * (double) (x_ps_max))
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - node_xy[1 + node * 2]) * (double) (y_ps_min)
                         + (node_xy[1 + node * 2] - y_min) * (double) (y_ps_max))
                        / (y_max - y_min));

                    file_unit.Add("  " + x_ps
                                       + "  " + y_ps + 5
                                       + "  moveto (" + (node + 1) + ") show");
                }
            }

            //
            //  Draw the points.
            //
            if (point_num <= 200)
            {
                circle_size = 5;
            }
            else if (point_num <= 500)
            {
                circle_size = 4;
            }
            else if (point_num <= 1000)
            {
                circle_size = 3;
            }
            else if (point_num <= 5000)
            {
                circle_size = 2;
            }
            else
            {
                circle_size = 1;
            }

            if (1 <= point_show)
            {
                file_unit.Add("%");
                file_unit.Add("%  Draw filled dots at the points.");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to green.");
                file_unit.Add("%");
                file_unit.Add("0.150  0.750  0.000 setrgbcolor");
                file_unit.Add("%");

                for (point = 0; point < point_num; point++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - point_xy[0 + point * 2]) * (double) (x_ps_min)
                         + (point_xy[0 + point * 2] - x_min) * (double) (x_ps_max))
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - point_xy[1 + point * 2]) * (double) (y_ps_min)
                         + (point_xy[1 + point * 2] - y_min) * (double) (y_ps_max))
                        / (y_max - y_min));

                    file_unit.Add("newpath  " + x_ps
                                              + "  " + y_ps
                                              + "  " + circle_size
                                              + "  0 360 arc closepath fill");
                }
            }

            //
            //  Label the points.
            //
            if (2 <= point_show)
            {
                file_unit.Add("%");
                file_unit.Add("%  Label the point:");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to darker green.");
                file_unit.Add("%");
                file_unit.Add("0.250  0.850  0.000 setrgbcolor");
                file_unit.Add("/Times-Roman findfont");
                file_unit.Add("0.20 inch scalefont");
                file_unit.Add("setfont");
                file_unit.Add("%");

                for (point = 0; point < point_num; point++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - point_xy[0 + point * 2]) * (double) (x_ps_min)
                         + (+point_xy[0 + point * 2] - x_min) * (double) (x_ps_max))
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - point_xy[1 + point * 2]) * (double) (y_ps_min)
                         + (point_xy[1 + point * 2] - y_min) * (double) (y_ps_max))
                        / (y_max - y_min));

                    file_unit.Add("  " + x_ps
                                       + "  " + y_ps + 5
                                       + "  moveto (" + (point + 1) + ") show");
                }
            }

            file_unit.Add("%");
            file_unit.Add("restore  showpage");
            file_unit.Add("%");
            file_unit.Add("%  End of page.");
            file_unit.Add("%");
            file_unit.Add("%%Trailer");
            file_unit.Add("%%EOF");

            try
            {
                File.WriteAllLines(file_name, file_unit);
            }
            catch
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_POINTS_PLOT - Fatal error!");
                Console.WriteLine("  Could not open the output EPS file.");
            }

        }

        public static void triangle_element_data_example(int element_num, int element_order,
                int element_att_num, ref int[] element_node, ref double[] element_att)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ELEMENT_DATA_EXAMPLE returns the element information for the example.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int ELEMENT_NUM, the number of elements.
            //
            //    Input, int ELEMENT_ORDER, the order of the elements.
            //
            //    Input, int ELEMENT_ATT_NUM, the number of element attributes.
            //
            //    Output, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
            //    nodes that make up each element.
            //
            //    Output, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
            //    of each element.
            //
        {
            int[] element_node_save =
                {
                    1, 2, 6,
                    7, 6, 2,
                    2, 3, 7,
                    8, 7, 3,
                    3, 4, 8,
                    9, 8, 4,
                    4, 5, 9,
                    10, 9, 5,
                    6, 7, 11,
                    12, 11, 7,
                    7, 8, 12,
                    13, 12, 8,
                    8, 9, 13,
                    14, 13, 9,
                    9, 10, 14,
                    15, 14, 10,
                    11, 12, 16,
                    17, 16, 12,
                    12, 13, 17,
                    18, 17, 13,
                    16, 17, 19,
                    20, 19, 17,
                    17, 18, 20,
                    21, 20, 18
                }
                ;

            i4mat_copy(element_order, element_num, element_node_save, ref element_node);

        }

        public static void triangle_element_data_read(string element_file, int element_num,
                int element_order, int element_att_num, ref int[] element_node,
                ref double[] element_att)

            //*****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ELEMENT_DATA_READ reads the header information from an element file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string ELEMENT_FILE, the name of the file to be read.
            //
            //    Input, int ELEMENT_NUM, the number of elements.
            //
            //    Input, int ELEMENT_ORDER, the order of the elements.
            //
            //    Input, int ELEMENT_ATT_NUM, number of element attributes listed on each 
            //    node record.
            //
            //    Output, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
            //    nodes that make up each element.
            //
            //    Output, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
            //    of each element.
            //
        {
            int element;
            int i;
            int i1;
            int i2;
            int i3;
            string[] inputlines;
            int ival;
            double value;

            element = -1;

            try
            {
                inputlines = File.ReadAllLines(element_file);
            }
            catch
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_ELEMENT_DATA_READ - Fatal error!");
                Console.WriteLine("  Could not open file.");
                return;
            }

            foreach (string input in inputlines)
            {
                string[] tokens = Helpers.splitStringByWhitespace(input);
                /*
                Read, but ignore, dimension line.
                */
                if (element == -1)
                {
                    i1 = Convert.ToInt32(tokens[0]);
                    i2 = Convert.ToInt32(tokens[1]);
                    i3 = Convert.ToInt32(tokens[2]);
                }
                else
                {
                    int index = 0;
                    ival = Convert.ToInt32(tokens[index]);
                    index++;

                    for (i = 0; i < element_order; i++)
                    {
                        ival = Convert.ToInt32(tokens[index]);
                        index++;
                        element_node[i + element * element_order] = ival;
                    }

                    for (i = 0; i < element_att_num; i++)
                    {
                        value = Convert.ToInt32(tokens[index]);
                        index++;
                        element_att[i + element * element_att_num] = value;
                    }
                }

                element = element + 1;

                if (element_num <= element)
                {
                    break;
                }
            }
        }

        public static void triangle_element_size_example(ref int element_num, ref int element_order,
                ref int element_att_num)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ELEMENT_SIZE_EXAMPLE returns the element size information for the example.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Output, int *ELEMENT_NUM, the number of elements.
            //
            //    Output, int *ELEMENT_ORDER, the order of the elements.
            //
            //    Output, int *ELEMENT_ATT_NUM, the number of element attributes.
            //
        {
            element_num = 24;
            element_order = 3;
            element_att_num = 0;
        }

        public static void triangle_element_size_read(string element_file, ref int element_num,
                ref int element_order, ref int element_att_num)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ELEMENT_SIZE_READ reads the header information from an element file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string ELEMENT_FILE, the name of the file to be read.
            //
            //    Output, int *ELEMENT_NUM, the number of elements.
            //
            //    Output, int *ELEMENT_ORDER, the order of the elements.
            //
            //    Output, int *ELEMENT_ATT_NUM, the number of element attributes.
            //
        {

            try
            {
                string input = File.ReadAllLines(element_file)[0];
                string[] tokens = Helpers.splitStringByWhitespace(input);
                element_num = Convert.ToInt32(tokens[0]);
                element_order = Convert.ToInt32(tokens[1]);
                element_att_num = Convert.ToInt32(tokens[2]);
            }
            catch
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_ELEMENT_SIZE_READ - Fatal error!");
                Console.WriteLine("  Could not open file.");
            }
        }

        public static void triangle_element_write(string element_file, int element_num,
                int element_order, int element_att_num, int[] element_node,
                double[] element_att)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ELEMENT_WRITE writes a TRIANGLE ".ele" file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string ELEMENT_FILE, the name of the file to be written.
            //
            //    Input, int ELEMENT_NUM, the number of elements.
            //
            //    Input, int ELEMENT_ORDER, the order of the elements.
            //
            //    Input, int ELEMENT_ATT_NUM, the number of element attributes.
            //
            //    Input, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
            //    nodes that make up each element.
            //
            //    Input, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
            //    of each element.
            //
        {
            int att;
            int element;
            int order;
            List<string> output = new List<string>();


            output.Add("  " + element_num
                            + "  " + element_order
                            + "  " + element_att_num + "");

            for (element = 0; element < element_num; element++)
            {
                string tmp = "  " + (element + 1);
                for (order = 0; order < element_order; order++)
                {
                    tmp += "  " + element_node[order + element * element_order];
                }

                for (att = 0; att < element_att_num; att++)
                {
                    tmp += element_att[att + element * element_att_num];
                }

                output.Add(tmp);
            }

            File.WriteAllLines(element_file, output);
        }

        public static void triangle_node_data_example(int node_num, int node_dim, int node_att_num,
                int node_marker_num, ref double[] node_coord, ref double[] node_att,
                ref int[] node_marker)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NODE_DATA_EXAMPLE returns the node information for the example.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int NODE_NUM, the number of nodes.
            //
            //    Input, int NODE_DIM, the spatial dimension.
            //
            //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
            //    node record.
            //
            //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
            //    boundary marker value.
            //
            //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
            //
            //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
            //
            //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
            //
        {
            double[] node_coord_save =
                {
                    0.0, 0.0,
                    1.0, 0.0,
                    2.0, 0.0,
                    3.0, 0.0,
                    4.0, 0.0,
                    0.0, 1.0,
                    1.0, 1.0,
                    2.0, 1.0,
                    3.0, 1.0,
                    4.0, 1.0,
                    0.0, 2.0,
                    1.0, 2.0,
                    2.0, 2.0,
                    3.0, 2.0,
                    4.0, 2.0,
                    0.0, 3.0,
                    1.0, 3.0,
                    2.0, 3.0,
                    0.0, 4.0,
                    1.0, 4.0,
                    2.0, 4.0
                }
                ;
            int[] node_marker_save =
                {
                    1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
                    1, 0, 0, 1, 1, 1, 0, 1, 1, 1,
                    1
                }
                ;

            r8mat_copy(2, 21, node_coord_save, ref node_coord);
            i4vec_copy(21, node_marker_save, ref node_marker);

        }

        public static void triangle_node_data_read(string node_file, int node_num, int node_dim,
                int node_att_num, int node_marker_num, ref double[] node_coord, ref double[] node_att,
                ref int[] node_marker)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NODE_HEADER_READ reads the header information from a node file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string NODE_FILE, the name of the node file to be read.
            //
            //    Input, int NODE_NUM, the number of nodes.
            //
            //    Input, int NODE_DIM, the spatial dimension.
            //
            //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
            //    node record.
            //
            //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
            //    boundary marker value.
            //
            //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
            //
            //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
            //
            //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
            //
        {
            int i;
            int i1;
            int i2;
            int i3;
            int i4;
            string[] inputlines;
            int ival;
            int node;
            double value;

            node = -1;

            try
            {
                inputlines = File.ReadAllLines(node_file);
            }
            catch
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_NODE_DATA_READ - Fatal error!");
                Console.WriteLine("  Could not open file.");
                return;
            }

            foreach (string input in inputlines)
            {
                string[] tokens = Helpers.splitStringByWhitespace(input);
                //
                //  Read, but ignore, dimension line.
                //
                if (node == -1)
                {
                    i1 = Convert.ToInt32(tokens[0]);
                    i2 = Convert.ToInt32(tokens[1]);
                    i3 = Convert.ToInt32(tokens[2]);
                    i4 = Convert.ToInt32(tokens[3]);
                }
                else
                {
                    int index = 0;
                    ival = Convert.ToInt32(tokens[index]);
                    index++;

                    for (i = 0; i < node_dim; i++)
                    {
                        value = Convert.ToInt32(tokens[index]);
                        index++;
                        node_coord[i + node * node_dim] = value;
                    }

                    for (i = 0; i < node_att_num; i++)
                    {
                        value = Convert.ToInt32(tokens[index]);
                        index++;
                        node_att[i + node * node_att_num] = value;
                    }

                    for (i = 0; i < node_marker_num; i++)
                    {
                        ival = Convert.ToInt32(tokens[index]);
                        index++;
                        node_marker[i + node * node_marker_num] = ival;
                    }
                }

                node = node + 1;

                if (node_num <= node)
                {
                    break;
                }
            }
        }

        public static void triangle_node_size_example(ref int node_num, ref int node_dim,
                ref int node_att_num, ref int node_marker_num)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NODE_SIZE_EXAMPLE returns the sizes of node information for the example.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Output, int *NODE_NUM, the number of nodes.
            //
            //    Output, int *NODE_DIM, the spatial dimension.
            //
            //    Output, int *NODE_ATT_NUM, number of node attributes listed on each 
            //    node record.
            //
            //    Output, int *NODE_MARKER_NUM, 1 if every node record includes a final
            //    boundary marker value.
            //
        {
            node_num = 21;
            node_dim = 2;
            node_att_num = 0;
            node_marker_num = 1;
        }

        public static void triangle_node_size_read(string node_file, ref int node_num, ref int node_dim,
                ref int node_att_num, ref int node_marker_num)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NODE_SIZE_READ reads the header information from a node file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string NODE_FILE, the name of the node file to be read.
            //
            //    Output, int *NODE_NUM, the number of nodes.
            //
            //    Output, int *NODE_DIM, the spatial dimension.
            //
            //    Output, int *NODE_ATT_NUM, number of node attributes listed on each 
            //    node record.
            //
            //    Output, int *NODE_MARKER_NUM, 1 if every node record includes a final
            //    boundary marker value.
            //
        {
            string input;

            input = File.ReadAllLines(node_file)[0];

            string[] tokens = Helpers.splitStringByWhitespace(input);

            node_num = Convert.ToInt32(tokens[0]);
            node_dim = Convert.ToInt32(tokens[1]);
            node_att_num = Convert.ToInt32(tokens[2]);
            node_marker_num = Convert.ToInt32(tokens[3]);

        }

        public static void triangle_node_write(string node_file, int node_num, int node_dim,
                int node_att_num, int node_marker_num, ref double[] node_coord,
                ref double[] node_att, ref int[] node_marker)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_NODE_WRITE writes a TRIANGLE ".node" file.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    07 December 2010
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string NODE_FILE, the name of the node file to be written.
            //
            //    Input, int NODE_NUM, the number of nodes.
            //
            //    Input, int NODE_DIM, the spatial dimension.
            //
            //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
            //    node record.
            //
            //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
            //    boundary marker value.
            //
            //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
            //
            //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
            //
            //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
            //
        {
            int att;
            int dim;
            int node;
            List<string> output = new List<string>();

            output.Add("  " + node_num
                            + "  " + node_dim
                            + "  " + node_att_num
                            + "  " + node_marker_num + "");

            for (node = 0; node < node_num; node++)
            {
                string tmp = "  " + (node + 1);
                for (dim = 0; dim < node_dim; dim++)
                {
                    tmp += "  " + node_coord[dim + node * node_dim];
                }

                for (att = 0; att < node_att_num; att++)
                {
                    tmp += "  " + node_att[att + node * node_att_num];
                }

                if (node_marker_num == 1)
                {
                    tmp += "  " + node_marker[node];
                }

                output.Add(tmp);
            }

            File.WriteAllLines(node_file, output);

        }

        public static double[] triangle_xsi_to_xy(double[] t, double[] xsi)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_XSI_TO_XY converts from barycentric to XY coordinates in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    04 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Input, double XSI[3], the barycentric coordinates of a point.
            //
            //    Output, double TRIANGLE_XSI_TO_XY[2], the Cartesian coordinates of the point.
            //
        {
            double[] p;

            p = new double[2];

            p[0] = xsi[0] * t[0 + 0 * 2] + xsi[1] * t[0 + 1 * 2] + xsi[2] * t[0 + 2 * 2];
            p[1] = xsi[0] * t[1 + 0 * 2] + xsi[1] * t[1 + 1 * 2] + xsi[2] * t[1 + 2 * 2];

            return p;
        }

        public static double[] triangle_xy_to_xsi(double[] t, double[] p)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_XY_TO_XSI converts from XY to barycentric in 2D.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    04 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[2*3], the triangle vertices.
            //
            //    Input, double P[2], the XY coordinates of a point.
            //
            //    Output, double TRIANGLE_XY_TO_XSI[3], the barycentric coordinates of the point.
            //
        {
            double det;
            double[] xsi;

            xsi = new double[3];

            det = (t[0 + 0 * 2] - t[0 + 2 * 2]) * (t[1 + 1 * 2] - t[1 + 2 * 2])
                  - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (t[1 + 0 * 2] - t[1 + 2 * 2]);

            xsi[0] = ((t[1 + 1 * 2] - t[1 + 2 * 2]) * (p[0] - t[0 + 2 * 2])
                      - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (p[1] - t[1 + 2 * 2])) / det;

            xsi[1] = (-(t[1 + 0 * 2] - t[1 + 2 * 2]) * (p[0] - t[0 + 2 * 2])
                      + (t[0 + 0 * 2] - t[0 + 2 * 2]) * (p[1] - t[1 + 2 * 2])) / det;

            xsi[2] = 1.0 - xsi[0] - xsi[1];

            return xsi;
        }

        public static void triangle_svg(string plot_filename, double[] t, int p_num, double[] p)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_SVG plots a triangle and points in SVG format.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    21 April 2014
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, string PLOT_FILENAME, the name of the output file.
            //
            //    Input, double T[2*3], points forming a triangle.
            //
            //    Input, int P_NUM, the number of points.
            //
            //    Input, double P[2*P_NUM], the points.
            //
        {
            int i4;
            int i4_max;
            int i4_min;
            int j;
            int j4;
            int j4_max;
            int j4_min;
            List<string> output = new List<string>();
            int r;
            double x_max;
            double x_min;
            double x_scale;
            double y_max;
            double y_min;
            double y_scale;
            //
            //  Determine SCALE, the maximum data range.
            //
            x_max = p[0 + 0 * 2];
            x_min = p[0 + 0 * 2];
            for (j = 0; j < p_num; j++)
            {
                x_max = Math.Max(x_max, p[0 + j * 2]);
                x_min = Math.Min(x_min, p[0 + j * 2]);
            }

            for (j = 0; j < 3; j++)
            {
                x_max = Math.Max(x_max, t[0 + j * 2]);
                x_min = Math.Min(x_min, t[0 + j * 2]);
            }

            x_scale = x_max - x_min;
            x_max = x_max + 0.05 * x_scale;
            x_min = x_min - 0.05 * x_scale;
            x_scale = x_max - x_min;

            y_max = p[1 + 0 * 2];
            y_min = p[1 + 0 * 2];
            for (j = 0; j < p_num; j++)
            {
                y_max = Math.Max(y_max, p[1 + j * 2]);
                y_min = Math.Min(y_min, p[1 + j * 2]);
            }

            for (j = 0; j < 3; j++)
            {
                y_max = Math.Max(y_max, t[1 + j * 2]);
                y_min = Math.Min(y_min, t[1 + j * 2]);
            }

            y_scale = y_max - y_min;
            y_max = y_max + 0.05 * y_scale;
            y_min = y_min - 0.05 * y_scale;
            y_scale = y_max - y_min;

            i4_min = 1;
            j4_min = 1;
            if (x_scale < y_scale)
            {
                i4_max = (int) (0.5 + 500.0 * x_scale / y_scale);
                j4_max = 500;
            }
            else
            {
                i4_max = 500;
                j4_max = (int) (0.5 + 500.0 * y_scale / x_scale);
            }

            //
            //  Write that junk.
            //
            output.Add("<?xml version = \"1.0\" standalone=\"no\"?>");
            output.Add("");
            output.Add("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"");
            output.Add("  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">");
            output.Add("");
            output.Add("<svg");
            output.Add("  width=\"" + i4_max + "\"");
            output.Add("  height=\"" + j4_max + "\"");
            output.Add("  viewbox=\"" + i4_min
                                      + "," + j4_min
                                      + "," + i4_max
                                      + "," + j4_max + "\"");
            output.Add("  xmlns=\"http://www.w3.org/2000/svg\"");
            output.Add("  version=\"1.1\">");
            output.Add("  <desc>");
            output.Add("    Triangulation created by triangle_svg.c");
            output.Add("  </desc>");
            //
            //  Draw the triangle.
            //
            output.Add("  <polygon");
            output.Add("    fill=\"pink\"");
            output.Add("    stroke=\"black\"");
            output.Add("    stroke-width=\"2\"");
            output.Add("    points=\"");

            for (j = 0; j < 3; j++)
            {
                i4 = r8_to_i4(x_min, x_max, t[0 + j * 2], i4_min, i4_max);
                j4 = r8_to_i4(y_max, y_min, t[1 + j * 2], j4_min, j4_max);
                output.Add("      " + i4 + "," + j4 + "");
            }

            output.Add("  \" />");
            //
            //  Draw points.
            //
            for (j = 0; j < p_num; j++)
            {
                i4 = r8_to_i4(x_min, x_max, p[0 + j * 2], i4_min, i4_max);
                j4 = r8_to_i4(y_max, y_min, p[1 + j * 2], j4_min, j4_max);
                r = 5;

                output.Add("  <circle");
                output.Add("    cx=\"" + i4 + "\"");
                output.Add("    cy=\"" + j4 + "\"");
                output.Add("    r=\"" + r + "\"");
                output.Add("    fill=\"blue\"");
                output.Add("    stroke=\"black\"");
                output.Add("    stroke-width=\"2\"");
                output.Add("  />");
            }

            //
            //  End of plot.
            //
            output.Add("</svg>");

            File.WriteAllLines(plot_filename, output);

            Console.WriteLine("");
            Console.WriteLine("  Graphics data written to file \"" + plot_filename + "\"");
        }

        public static void triangle_angles_3d(double[] t, ref double[] angle, int angleIndex = 0)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_ANGLES_3D computes the angles of a triangle in 3D.
            //
            //  Discussion:
            //
            //    The law of cosines is used:
            //
            //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
            //
            //    where GAMMA is the angle opposite side C.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    30 July 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double T[3*3], the triangle vertices.
            //
            //    Output, double ANGLE[3], the angles opposite
            //    sides P1-P2, P2-P3 and P3-P1, in radians.
            //
        {
            double a;
            double b;
            double c;
            

            a = Math.Sqrt(Math.Pow(t[0 + 1 * 3] - t[0 + 0 * 3], 2)
                     + Math.Pow(t[1 + 1 * 3] - t[1 + 0 * 3], 2)
                     + Math.Pow(t[2 + 1 * 3] - t[2 + 0 * 3], 2));

            b = Math.Sqrt(Math.Pow(t[0 + 2 * 3] - t[0 + 1 * 3], 2)
                          + Math.Pow(t[1 + 2 * 3] - t[1 + 1 * 3], 2)
                          + Math.Pow(t[2 + 2 * 3] - t[2 + 1 * 3], 2));

            c = Math.Sqrt(Math.Pow(t[0 + 0 * 3] - t[0 + 2 * 3], 2)
                          + Math.Pow(t[1 + 0 * 3] - t[1 + 2 * 3], 2)
                          + Math.Pow(t[2 + 0 * 3] - t[2 + 2 * 3], 2));
            //
            //  Take care of a ridiculous special case.
            //
            if (a == 0.0 && b == 0.0 && c == 0.0)
            {
                angle[angleIndex + 0] = 2.0 * Math.PI / 3.0;
                angle[angleIndex + 1] = 2.0 * Math.PI / 3.0;
                angle[angleIndex + 2] = 2.0 * Math.PI / 3.0;
                return;
            }

            if (c == 0.0 || a == 0.0)
            {
                angle[angleIndex + 0] = Math.PI;
            }
            else
            {
                angle[angleIndex + 0] = r8_acos((c * c + a * a - b * b) / (2.0 * c * a));
            }

            if (a == 0.0 || b == 0.0)
            {
                angle[angleIndex + 1] = Math.PI;
            }
            else
            {
                angle[angleIndex + 1] = r8_acos((a * a + b * b - c * c) / (2.0 * a * b));
            }

            if (b == 0.0 || c == 0.0)
            {
                angle[angleIndex + 2] = Math.PI;
            }
            else
            {
                angle[angleIndex + 2] = r8_acos((b * b + c * c - a * a) / (2.0 * b * c));
            }
        }

        public static double triangle_area_3d(double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_AREA_3D computes the area of a triangle in 3D.
            //
            //  Discussion:
            //
            //    This routine uses the fact that the norm of the cross product vector
            //    is the area of the parallelogram they form.  The triangle they
            //    form has half that area.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    17 October 2005
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Reference:
            //
            //    Adrian Bowyer, John Woodwark,
            //    A Programmer's Geometry,
            //    Butterworths, 1983.
            //
            //  Parameters:
            //
            //    Input, double T[3*3], the vertices of the triangle.
            //
            //    Output, double TRIANGLE_AREA_3D, the area of the triangle.
            //
        {
            double area;
            double[] cross;
            int i;
            //
            //  Compute the cross product vector.
            //
            cross = new double[3];

            cross[0] = (t[1 + 1 * 3] - t[1 + 0 * 3])
                       * (t[2 + 2 * 3] - t[2 + 0 * 3])
                       - (t[2 + 1 * 3] - t[2 + 0 * 3])
                       * (t[1 + 2 * 3] - t[1 + 0 * 3]);

            cross[1] = (t[2 + 1 * 3] - t[2 + 0 * 3])
                       * (t[0 + 2 * 3] - t[0 + 0 * 3])
                       - (t[0 + 1 * 3] - t[0 + 0 * 3])
                       * (t[2 + 2 * 3] - t[2 + 0 * 3]);

            cross[2] = (t[0 + 1 * 3] - t[0 + 0 * 3])
                       * (t[1 + 2 * 3] - t[1 + 0 * 3])
                       - (t[1 + 1 * 3] - t[1 + 0 * 3])
                       * (t[0 + 2 * 3] - t[0 + 0 * 3]);

            area = 0.0;
            for (i = 0; i < 3; i++)
            {
                area = area + Math.Pow(cross[i], 2);
            }

            area = 0.5 * Math.Sqrt(area);

            return area;
        }

        public static double triangle_area(double[] vert1, double[] vert2, double[] vert3)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_AREA returns the area of a triangle.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU GPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
            //    C++ version by John Burkardt.
            //
            //  Reference:
            //
            //    Hong Xiao, Zydrunas Gimbutas,
            //    A numerical algorithm for the construction of efficient quadrature
            //    rules in two and higher dimensions,
            //    Computers and Mathematics with Applications,
            //    Volume 59, 2010, pages 663-676.
            //
            //  Parameters:
            //
            //    Input, double VERT1[2], VERT2[2], VERT3[2], the vertices of
            //    the triangle.
            //
            //    Output, double TRIANGLE_AREA, the area of the triangle.
            //
        {
            double value;

            value = 0.5 *
                    (
                        (vert2[0] - vert1[0]) * (vert3[1] - vert1[1])
                        - (vert3[0] - vert1[0]) * (vert2[1] - vert1[1])
                    );

            return value;
        }

        public static int triangle_lower_to_i4(int i, int j)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_LOWER_TO_I4 converts a lower triangular coordinate to an integer.
            //
            //  Discussion:
            //
            //    Triangular coordinates are handy when storing a naturally triangular
            //    array (such as the lower half of a matrix) in a linear array.
            //
            //    Thus, for example, we might consider storing
            //
            //    (0,0)
            //    (1,0) (1,1)
            //    (2,0) (2,1) (2,2)
            //    (3,0) (3,1) (3,2) (3,3)
            //
            //    as the linear array
            //
            //    (0,0) (1,0) (1,1) (2,0) (2,1) (2,2) (3,0) (3,1) (3,2) (3,3)
            //
            //    Here, the quantities in parenthesis represent the natural row and
            //    column indices of a single number when stored in a rectangular array.
            //
            //    Thus, our goal is, given the row I and column J of the data,
            //    to produce the value K which indicates its position in the linear
            //    array.
            //
            //    The triangular numbers are the indices associated with the
            //    diagonal elements of the original array, T(0,0), T(1,1), T(2,2), 
            //    T(3,3) and so on.
            //
            //    The formula is:
            //
            //      K = J + ( ( I * ( I + 1 ) ) / 2
            //
            //  Example:
            //
            //    I  J  K
            //
            //    0  0  0
            //    1  0  1
            //    1  1  2
            //    2  0  3
            //    2  1  4
            //    2  2  5
            //    3  0  6
            //    3  1  7
            //    3  2  8
            //    3  3  9
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    18 January 2009
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int I, J, the row and column indices.  I and J must
            //    be nonnegative, and J must not be greater than I.
            //
            //    Output, int TRIANGLE_LOWER_TO_I4, the linear index of the (I,J) element.
            //
        {
            int value;

            if (i < 0)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
                Console.WriteLine("  I < 0.");
                Console.WriteLine("  I = " + i + "");
                return(1);
            }
            else if (j < 0)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
                Console.WriteLine("  J < 0.");
                Console.WriteLine("  J = " + j + "");
                return(1);
            }
            else if (i < j)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
                Console.WriteLine("  I < J.");
                Console.WriteLine("  I = " + i + "");
                Console.WriteLine("  J = " + j + "");
                return(1);
            }

            value = j + (i * (i + 1)) / 2;

            return value;
        }

        public static int triangle_upper_to_i4(int i, int j)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_UPPER_TO_I4 converts an upper triangular coordinate to an integer.
            //
            //  Discussion:
            //
            //    Triangular coordinates are handy when storing a naturally triangular
            //    array (such as the upper half of a matrix) in a linear array.
            //
            //    Thus, for example, we might consider storing
            //
            //    (0,0) (0,1) (0,2) (0,3)
            //          (1,1) (1,2) (1,3)
            //                (2,2) (2,3)
            //                      (3,3)
            //
            //    as the linear array
            //
            //    (0,0) (0,1) (1,1) (0,2) (1,2) (2,2) (0,3) (1,3) (2,3) (3,3)
            //
            //    Here, the quantities in parenthesis represent the natural row and
            //    column indices of a single number when stored in a rectangular array.
            //
            //    Thus, our goal is, given the row I and column J of the data,
            //    to produce the value K which indicates its position in the linear
            //    array.
            //
            //    The triangular numbers are the indices associated with the
            //    diagonal elements of the original array, T(0,0), T(1,1), T(2,2), 
            //    T(3,3) and so on.
            //
            //    The formula is:
            //
            //      K = I + ( ( J * ( J + 1 ) ) / 2
            //
            //  Example:
            //
            //    I  J  K
            //
            //    0  0  0
            //    0  1  1
            //    1  1  2
            //    0  2  3
            //    1  2  4
            //    2  2  5
            //    0  3  6
            //    1  3  7
            //    2  3  8
            //    3  3  9
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license. 
            //
            //  Modified:
            //
            //    23 March 2017
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, int I, J, the row and column indices.  I and J must
            //    be nonnegative, and I must not be greater than J.
            //
            //    Output, int TRIANGLE_UPPER_TO_I4, the linear index of the (I,J) element.
            //
        {
            int value;

            if (i < 0)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
                Console.WriteLine("  I < 0.");
                Console.WriteLine("  I = " + i + "");
                return (1);
            }
            else if (j < 0)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
                Console.WriteLine("  J < 0.");
                Console.WriteLine("  J = " + j + "");
                return (1);
            }
            else if (j < i)
            {
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
                Console.WriteLine("  J < I.");
                Console.WriteLine("  I = " + i + "");
                Console.WriteLine("  J = " + j + "");
                return (1);
            }

            value = i + (j * (j + 1)) / 2;

            return value;
        }

        public static double[] triangle_to_ref(double[] tvert1, double[] tvert2,
                double[] tvert3, double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_TO_REF maps points from any triangle to the reference triangle.
            //
            //  Discussion:
            //
            //    The reference triangle has vertices:
            //
            //      ( -1, -1/sqrt(3) )
            //      ( +1, -1/sqrt(3) )
            //      (  0, +2/sqrt(3) )
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
            //    of the vertices of the triangle.  These vertices will be taken
            //    to be the images of (0,0), (1,0) and (0,1) respectively.
            //
            //    Input, double T[2], the coordinates of a point in the triangle.
            //
            //    Output, double TRIANGLE_TO_REF[2], the coordinates of a point in the
            //    reference triangle.
            //
        {
            double[] r;
            double[] rvert1 = new double[2];
            double[] rvert2 = new double[2];
            double[] rvert3 = new double[2];
            double[] s;

            s = triangle_to_simplex(tvert1, tvert2, tvert3, t);

            rvert1[0] = -1.0;
            rvert1[1] = -1.0 / Math.Sqrt(3.0);
            rvert2[0] = +1.0;
            rvert2[1] = -1.0 / Math.Sqrt(3.0);
            rvert3[0] = 0.0;
            rvert3[1] = 2.0 / Math.Sqrt(3.0);

            r = Burkardt.SimplexNS.Simplex.simplex_to_triangle(rvert1, rvert2, rvert3, s);

            return r;
        }

        public static double[] triangle_to_simplex(double[] tvert1, double[] tvert2,
                double[] tvert3, double[] t)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANGLE_TO_SIMPLEX maps points from any triangle to the simplex.
            //
            //  Discussion:
            //
            //    The simplex has vertices:
            //
            //      (  0, 0 )
            //      (  1, 0 )
            //      (  0, 1 )
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
            //    of the vertices of the triangle.  These vertices will be taken
            //    to be the images of (0,0), (1,0) and (0,1) respectively.
            //
            //    Input, double T[2]), the coordinates of a point in the triangle.
            //
            //    Output, double TRIANGLE_TO_SIMPLEX[2], the coordinates of the
            //    point in the simplex.
            //
        {
            double[] s;

            s = new double[2];

            s[0] = ((tvert3[1] - tvert1[1]) * (t[0] - tvert1[0])
                    - (tvert3[0] - tvert1[0]) * (t[1] - tvert1[1]))
                   / ((tvert3[1] - tvert1[1]) * (tvert2[0] - tvert1[0])
                      - (tvert3[0] - tvert1[0]) * (tvert2[1] - tvert1[1]));

            s[1] = ((tvert2[0] - tvert1[0]) * (t[1] - tvert1[1])
                    - (tvert2[1] - tvert1[1]) * (t[0] - tvert1[0]))
                   / ((tvert3[1] - tvert1[1]) * (tvert2[0] - tvert1[0])
                      - (tvert3[0] - tvert1[0]) * (tvert2[1] - tvert1[1]));

            return s;
        }

        public static void trianmap(int numnodes, double[] vert1, double[] vert2, double[] vert3,
                ref double[] rnodes, ref double[] whts)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIANMAP maps rules from the reference triangle to the user triangle.
            //
            //  Discussion:
            //
            //    This routine maps the quadrature nodes on the reference
            //    triangle into a user-defined triangle specified by its vertices.
            //
            //    The weights are rescaled accordingly, so that
            //    the resulting quadrature will integrate correctly constants, i.e.
            //    the sum of the weights is the area of the user-defined triangle.
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU GPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
            //    C++ version by John Burkardt.
            //
            //  Reference:
            //
            //    Hong Xiao, Zydrunas Gimbutas,
            //    A numerical algorithm for the construction of efficient quadrature
            //    rules in two and higher dimensions,
            //    Computers and Mathematics with Applications,
            //    Volume 59, 2010, pages 663-676.
            //
            //  Parameters:
            //
            //    Input, int NUMNODES, the number of nodes.
            //
            //    Input, double VERT1[2], VERT2[2], VERT3[2], the vertices of
            //    the triangle on which the quadrature rule is to be constructed.
            //
            //    Input/output, double RNODES[2*NUMNODES], the nodes.
            //
            //    Input/output, double WHTS[NUMNODES], the weights.
            //
        {
            double area;
            int j;
            double scale;
            double u = 0;
            double v = 0;
            double x;
            double y;

            area = Math.Abs(triangle_area(vert1, vert2, vert3));

            scale = r8vec_sum(numnodes, whts);

            scale = area / scale;

            for (j = 0; j < numnodes; j++)
            {
                x = rnodes[0 + j * 2];
                y = rnodes[1 + j * 2];
                triasimp(x, y, ref u, ref v);
                x = (vert2[0] - vert1[0]) * u
                    + (vert3[0] - vert1[0]) * v + vert1[0];
                y = (vert2[1] - vert1[1]) * u
                    + (vert3[1] - vert1[1]) * v + vert1[1];
                rnodes[0 + j * 2] = x;
                rnodes[1 + j * 2] = y;
                whts[j] = whts[j] * scale;
            }

        }

        public static void triasimp(double x, double y, ref double uout, ref double vout)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    TRIASIMP maps a point from the reference triangle to the simplex.
            //
            //  Discussion:
            //
            //    Map the reference triangle with vertices
            //      (-1,-1/sqrt(3)), (1,-1/sqrt(3)), (0,2/sqrt(3))
            //    to the simplex with vertices
            //      (0,0), (1,0), (0,1).
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU GPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
            //    C++ version by John Burkardt.
            //
            //  Reference:
            //
            //    Hong Xiao, Zydrunas Gimbutas,
            //    A numerical algorithm for the construction of efficient quadrature
            //    rules in two and higher dimensions,
            //    Computers and Mathematics with Applications,
            //    Volume 59, 2010, pages 663-676.
            //
            //  Parameters:
            //
            //    Input, double X, Y, the coordinates of a point in the
            //    reference triangle.
            //
            //    Output, double &UOUT, &VOUT, the coordinates of the corresponding
            //    point in the simplex.
            //
        {
            double scale;

            scale = 1.0 / Math.Sqrt(3.0);

            uout = 0.5 * (x + 1.0) - 0.5 * scale * (y + scale);
            vout = 1.0 * scale * (y + scale);

        }

        public static double[] ref_to_koorn(double[] r)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    REF_TO_KOORN maps points from the reference to Koornwinder's triangle.
            //
            //  Discussion:
            //
            //    The reference triangle has vertices:
            //
            //      ( -1, -1/sqrt(3) )
            //      ( +1, -1/sqrt(3) )
            //      (  0, +2/sqrt(3) )
            //
            //    Koornwinder's triangle has vertices:
            //
            //      ( -1, -1 )
            //      ( +1, -1 )
            //      ( -1, +1 )
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double R[2], the coordinates of a point in the
            //    reference triangle.
            //
            //    Output, double REF_TO_KOORN[2], the coordinates of the point in
            //    the Koornwinder triangle.
            //
        {
            double a10;
            double a11;
            double a12;
            double a13;
            double a20;
            //double a21;
            double a22;
            double a23;
            double a30;
            //double a31;
            //double a32;
            double a33;
            double s3;
            double s6;
            double[] u;

            s3 = Math.Sqrt ( 3.0 );
            s6 = Math.Sqrt ( 6.0 );

            a10 = - 0.5;
            a11 =   1.0;
            a12 = - 1.0 / s3;
            a13 = - 1.0 / s6;

            a20 = - 0.5;
            //a21 =   0.0;
            a22 =   2.0 / s3;
            a23 = - 1.0 / s6;

            a30 = - 0.5;
            //a31 =   0.0;
            //a32 =   0.0;
            a33 =   0.5 * s6;

            u = new double[3];

            u[0] = a10 + a11 * r[0] + a12 * r[1] + a13 * r[2];
            u[1] = a20 +              a22 * r[1] + a23 * r[2];
            u[2] = a30 +                           a33 * r[2];

            return u;
        }

        public static double[] ref_to_triangle(double[] tvert1, double[] tvert2, double[] tvert3,
                double[] r)

            //****************************************************************************80
            //
            //  Purpose:
            //
            //    REF_TO_TRIANGLE maps points from the reference triangle to a triangle.
            //
            //  Discussion:
            //
            //    The reference triangle has vertices:
            //
            //      ( -1, -1/sqrt(3) )
            //      ( +1, -1/sqrt(3) )
            //      (  0, +2/sqrt(3) )
            //
            //  Licensing:
            //
            //    This code is distributed under the GNU LGPL license.
            //
            //  Modified:
            //
            //    30 June 2014
            //
            //  Author:
            //
            //    John Burkardt
            //
            //  Parameters:
            //
            //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
            //    of the vertices of the triangle.  These vertices will be taken
            //    to be the images of (0,0), (1,0) and (0,1) respectively.
            //
            //    Input, double R[2], the coordinates of a point in the
            //    reference triangle.
            //
            //    Output, double T(2), the coordinates of the point in
            //    the triangle.
            //
        {
            int i;
            double[] s;
            double[] t;
            double[] rvert1 = new double[2];
            double[] rvert2 = new double[2];
            double[] rvert3 = new double[2];

            rvert1[0] = -1.0;
            rvert1[1] = -1.0 / Math.Sqrt(3.0);
            rvert2[0] = +1.0;
            rvert2[1] = -1.0 / Math.Sqrt(3.0);
            rvert3[0] = 0.0;
            rvert3[1] = 2.0 / Math.Sqrt(3.0);

            s = triangle_to_simplex(rvert1, rvert2, rvert3, r);

            t = new double[2];

            for (i = 0; i < 2; i++)
            {
                t[i] = tvert1[i] * (1.0 - s[0] - s[1])
                       + tvert2[i] * s[0]
                       + tvert3[i] * s[1];
            }

            return t;
        }
    }
}