using System;
using System.Collections.Generic;
using System.IO;
using Burkardt.LineNS;
using Burkardt.Uniform;

namespace Burkardt.Types;

public static partial class typeMethods
{
    public static void subtriangle_next(int n, ref bool more, ref int i1, ref int j1, ref int i2, ref int j2,
            ref int i3, ref int j3)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    SUBTRIANGLE_NEXT computes the next subtriangle of a triangle.
        //
        //  Discussion:
        //
        //    The three sides of a triangle have been subdivided into N segments,
        //    inducing a natural subdivision of the triangle into N*N subtriangles.
        //    It is desired to consider each subtriangle, one at a time, in some
        //    definite order.  This routine can produce information defining each 
        //    of the subtriangles, one after another.
        //
        //    The subtriangles are described in terms of the integer coordinates 
        //    (I,J) of their vertices.  These coordinates both range from 0 to N,
        //    with the additional restriction that I + J <= N.
        //
        //    The vertices of each triangle are listed in counterclockwise order.
        //
        //  Example:
        //
        //    N = 4
        //
        //    4  *
        //       ||            
        //       16| 
        //    3  *--*
        //       |14|| 
        //       13\15| 
        //    2  *--*--*
        //       |\9|11|| 
        //       |8\10\12| 
        //    1  *--*--*--*
        //       |\2|\4|\6|| 
        //       |1\|3\|5\|7| 
        //   0   *--*--*--*--*
        //
        //       0  1  2  3  4
        //
        //    Rank  I1 J1  I2 J2  I3 J3
        //    ----  -----  -----  ----- 
        //       1   0  0   1  0   0  1
        //       2   1  1   0  1   1  0
        //       3   1  0   2  0   1  1
        //       4   2  1   1  1   2  0
        //       5   2  0   3  0   2  1
        //       6   3  1   1  1   3  0
        //       7   3  0   4  0   3  1
        //       8   0  1   1  1   0  2
        //       9   1  2   0  2   1  1
        //      10   1  1   2  1   1  2
        //      11   2  2   1  2   2  1
        //      12   2  1   3  1   2  2
        //      13   0  2   1  2   0  3
        //      14   1  3   0  3   1  2
        //      15   1  2   2  2   1  3
        //      16   0  3   1  3   0  4
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    27 March 2007
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int N, indicates the number of subdivisions of each side
        //    of the original triangle.
        //
        //    Input/output, bool &MORE.
        //    On first call, set MORE to FALSE.  Thereafter, the output value of MORE
        //    will be TRUE if there are more subtriangles that can be generated by
        //    further calls.  However, if MORE is returned as FALSE, the accompanying
        //    subtriangle information refers to the last subtriangle that can be
        //    generated.
        //
        //    Input/output, int &I1, &J1, &I2, &J2, &I3, &J3, the indices of the 
        //    vertices of the subtriangle.
        //
    {
        switch (n)
        {
            case <= 0:
                more = false;
                return;
        }

        switch (more)
        {
            case false:
            {
                i1 = 0;
                j1 = 0;
                i2 = 1;
                j2 = 0;
                i3 = 0;
                j3 = 1;

                more = n switch
                {
                    1 => false,
                    _ => true
                };

                break;
            }
            //
            default:
            {
                if (i2 < i3)
                {
                    i1 = i3;
                    j1 = j3;
                    i2 = i1 + 1;
                    j2 = j1;
                    i3 = i1;
                    j3 = j1 + 1;
                }
                //
                //  We last generated a triangle like
                //
                //    3
                //    ||
                //    | |
                //    |  |
                //    1---2
                //
                else if (i1 + 1 + j1 + 1 <= n)
                {
                    i1 += 1;
                    j1 += 1;
                    i2 = i1 - 1;
                    j2 = j1;
                    i3 = i1;
                    j3 = j1 - 1;
                }
                //
                //  We must be at the end of a row.
                //
                else
                {
                    i1 = 0;
                    j1 += 1;
                    i2 = i1 + 1;
                    j2 = j1;
                    i3 = i1;
                    j3 = j1 + 1;

                    if (n <= j1 + 1)
                    {
                        more = false;
                    }
                }

                break;
            }
        }
    }

    public static void triangle_angles_2d(double[] t, double[] angle)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ANGLES_2D computes the angles of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The law of cosines is used:
        //
        //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
        //
        //    where GAMMA is the angle opposite side C.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    30 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double ANGLE[3], the angles opposite
        //    sides P1-P2, P2-P3 and P3-P1, in radians.
        //
    {
        double a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                             + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));

        double b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                             + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));

        double c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                             + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
        switch (a)
        {
            //
            //  Take care of a ridiculous special case.
            //
            case 0.0 when b == 0.0 && c == 0.0:
                angle[0] = 2.0 * Math.PI / 3.0;
                angle[1] = 2.0 * Math.PI / 3.0;
                angle[2] = 2.0 * Math.PI / 3.0;
                return;
        }

        if (c == 0.0 || a == 0.0)
        {
            angle[0] = Math.PI;
        }
        else
        {
            angle[0] = r8_acos((c * c + a * a - b * b) / (2.0 * c * a));
        }

        if (a == 0.0 || b == 0.0)
        {
            angle[1] = Math.PI;
        }
        else
        {
            angle[1] = r8_acos((a * a + b * b - c * c) / (2.0 * a * b));
        }

        if (b == 0.0 || c == 0.0)
        {
            angle[2] = Math.PI;
        }
        else
        {
            angle[2] = r8_acos((b * b + c * c - a * a) / (2.0 * b * c));
        }
    }

    public static void triangle_reference_sample(int n, ref int seed, ref double[] p)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_REFERENCE_SAMPLE returns random points in the reference triangle.
        //
        //  Diagram:
        //
        //       3
        //    s  |.
        //    i  | .
        //    d  |  .
        //    e  |   .  side 2
        //       |    .
        //    3  |     .
        //       |      .
        //       1-------2
        //
        //         side 1
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    07 December 2006
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, integer N, the number of points to sample.
        //
        //    Input/output, int *SEED, a seed for the random number generator.
        //
        //    Output, double P[2*N], a random point in the triangle.
        //
    {
        int j;

        p = new double[n * 2];

        for (j = 0; j < n; j++)
        {
            double r = UniformRNG.r8_uniform_01(ref seed);
            //
            //  Interpret R as a percentage of the triangle's area.
            //
            //  Imagine a line L, parallel to side 1, so that the area between
            //  vertex 1 and line L is R percent of the full triangle's area.
            //
            //  The line L will intersect sides 2 and 3 at a fraction
            //  ALPHA = SQRT ( R ) of the distance from vertex 1 to vertices 2 and 3.
            //
            double alpha = Math.Sqrt(r);
            //
            //  Now choose, uniformly at random, a point on the line L.
            //
            double beta = UniformRNG.r8_uniform_01(ref seed);

            p[(0 + j * 2) % p.Length] = (1.0 - beta) * alpha;
            p[(1 + j * 2) % p.Length] = beta * alpha;
        }
    }

    public static void triangle_sample(double[] t, int n, ref int seed, ref double[] p, int pIndex = 0)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_SAMPLE returns random points in a triangle.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    06 December 2006
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Input, integer N, the number of points to sample.
        //
        //    Input/output, int *SEED, a seed for the random number generator.
        //
        //    Output, double P[2*N], a random point in the triangle.
        //
    {
        const int DIM_NUM = 2;

        int j;
        double[] p12 = new double[DIM_NUM];
        double[] p13 = new double[DIM_NUM];

        p = new double[2 * n];

        for (j = 0; j < n; j++)
        {
            double r = UniformRNG.r8_uniform_01(ref seed);
            //
            //  Interpret R as a percentage of the triangle's area.
            //
            //  Imagine a line L, parallel to side 1, so that the area between
            //  vertex 1 and line L is R percent of the full triangle's area.
            //
            //  The line L will intersect sides 2 and 3 at a fraction
            //  ALPHA = SQRT ( R ) of the distance from vertex 1 to vertices 2 and 3.
            //
            double alpha = Math.Sqrt(r);
            //
            //  Determine the coordinates of the points on sides 2 and 3 intersected
            //  by line L.
            //
            p12[0] = (1.0 - alpha) * t[0 + 0 * 2] + alpha * t[0 + 1 * 2];
            p12[1] = (1.0 - alpha) * t[1 + 0 * 2] + alpha * t[1 + 1 * 2];

            p13[0] = (1.0 - alpha) * t[0 + 0 * 2] + alpha * t[0 + 2 * 2];
            p13[1] = (1.0 - alpha) * t[1 + 0 * 2] + alpha * t[1 + 2 * 2];
            //
            //  Now choose, uniformly at random, a point on the line L.
            //
            double beta = UniformRNG.r8_uniform_01(ref seed);

            p[(pIndex + 0 + j * 2 + p.Length) % p.Length] = (1.0 - beta) * p12[0] + beta * p13[0];
            p[(pIndex + 1 + j * 2 + p.Length) % p.Length] = (1.0 - beta) * p12[1] + beta * p13[1];
        }
    }

    public static double[] triangle_angles_2d_new(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ANGLES_2D_NEW computes the angles of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The law of cosines is used:
        //
        //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
        //
        //    where GAMMA is the angle opposite side C.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    30 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double ANGLE[3], the angles opposite
        //    sides P1-P2, P2-P3 and P3-P1, in radians.
        //
    {
        double[] angle = new double[3];

        double a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                             + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));

        double b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                             + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));

        double c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                             + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
        switch (a)
        {
            //
            //  Take care of a ridiculous special case.
            //
            case 0.0 when b == 0.0 && c == 0.0:
                angle[0] = 2.0 * Math.PI / 3.0;
                angle[1] = 2.0 * Math.PI / 3.0;
                angle[2] = 2.0 * Math.PI / 3.0;
                return angle;
        }

        if (c == 0.0 || a == 0.0)
        {
            angle[0] = Math.PI;
        }
        else
        {
            angle[0] = Helpers.arc_cosine((c * c + a * a - b * b) / (2.0 * c * a));
        }

        if (a == 0.0 || b == 0.0)
        {
            angle[1] = Math.PI;
        }
        else
        {
            angle[1] = Helpers.arc_cosine((a * a + b * b - c * c) / (2.0 * a * b));
        }

        if (b == 0.0 || c == 0.0)
        {
            angle[2] = Math.PI;
        }
        else
        {
            angle[2] = Helpers.arc_cosine((b * b + c * c - a * a) / (2.0 * b * c));
        }

        return angle;
    }

    public static double triangle_area_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_AREA_2D computes the area of a triangle in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    03 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the vertices of the triangle.
        //
        //    Output, double TRIANGLE_AREA_2D, the area of the triangle.  AREA will
        //    be nonnegative.
        //
    {
        double area = 0.5 * (
            t[0 + 0 * 2] * (t[1 + 2 * 2] - t[1 + 1 * 2]) +
            t[0 + 1 * 2] * (t[1 + 0 * 2] - t[1 + 2 * 2]) +
            t[0 + 2 * 2] * (t[1 + 1 * 2] - t[1 + 0 * 2]));

        return area;
    }

    public static double[] triangle_centroid_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_CENTROID_2D computes the centroid of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The centroid of a triangle can also be considered the center
        //    of gravity, assuming that the triangle is made of a thin uniform
        //    sheet of massy material.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    03 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Adrian Bowyer, John Woodwark,
        //    A Programmer's Geometry,
        //    Butterworths, 1983.
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the vertices of the triangle.
        //
        //    Output, double TRIANGLE_CENTROID_2D[2], the coordinates of the centroid of the triangle.
        //
    {
        double[] centroid = new double[2];

        centroid[0] = (t[0 + 0 * 2] + t[0 + 1 * 2] + t[0 + 2 * 2]) / 3.0;
        centroid[1] = (t[1 + 0 * 2] + t[1 + 1 * 2] + t[1 + 2 * 2]) / 3.0;

        return centroid;
    }

    public static double[] triangle_circumcenter_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_CIRCUMCENTER_2D computes the circumcenter of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The circumcenter of a triangle is the center of the circumcircle, the
        //    circle that passes through the three vertices of the triangle.
        //
        //    The circumcircle contains the triangle, but it is not necessarily the
        //    smallest triangle to do so.
        //
        //    If all angles of the triangle are no greater than 90 degrees, then
        //    the center of the circumscribed circle will lie inside the triangle.
        //    Otherwise, the center will lie outside the triangle.
        //
        //    The circumcenter is the intersection of the perpendicular bisectors
        //    of the sides of the triangle.
        //
        //    In geometry, the circumcenter of a triangle is often symbolized by "O".
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    09 February 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double *TRIANGLE_CIRCUMCENTER_2D[2], the circumcenter of
        //    the triangle.
        //
    {
        const int DIM_NUM = 2;

        double[] center = new double[DIM_NUM];

        double asq = (t[0 + 1 * 2] - t[0 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2])
                     + (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[1 + 1 * 2] - t[1 + 0 * 2]);

        double csq = (t[0 + 2 * 2] - t[0 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
                     + (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[1 + 2 * 2] - t[1 + 0 * 2]);

        double top1 = (t[1 + 1 * 2] - t[1 + 0 * 2]) * csq - (t[1 + 2 * 2] - t[1 + 0 * 2]) * asq;
        double top2 = -(t[0 + 1 * 2] - t[0 + 0 * 2]) * csq + (t[0 + 2 * 2] - t[0 + 0 * 2]) * asq;

        double bot = (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
                     - (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2]);

        center[0] = t[0 + 0 * 2] + 0.5 * top1 / bot;
        center[1] = t[1 + 0 * 2] + 0.5 * top2 / bot;

        return center;
    }

    public static void triangle_circumcircle_2d(double[] t, ref double r, ref double[] pc)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_CIRCUMCIRCLE_2D computes the circumcircle of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The circumcenter of a triangle is the center of the circumcircle, the
        //    circle that passes through the three vertices of the triangle.
        //
        //    The circumcircle contains the triangle, but it is not necessarily the
        //    smallest triangle to do so.
        //
        //    If all angles of the triangle are no greater than 90 degrees, then
        //    the center of the circumscribed circle will lie inside the triangle.
        //    Otherwise, the center will lie outside the triangle.
        //
        //    The circumcenter is the intersection of the perpendicular bisectors
        //    of the sides of the triangle.
        //
        //    In geometry, the circumcenter of a triangle is often symbolized by "O".
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    04 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double *R, PC[2], the circumradius, and the coordinates of the 
        //    circumcenter of the triangle.
        //
    {
        //
        //  Circumradius.
        //
        double a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2) + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
        double b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2) + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
        double c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2) + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));

        double bot = (a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c);

        switch (bot)
        {
            case <= 0.0:
                r = -1.0;
                pc[0] = 0.0;
                pc[1] = 0.0;
                return;
        }

        r = a * b * c / Math.Sqrt(bot);
        //
        //  Circumcenter.
        //
        double top1 = (t[1 + 1 * 2] - t[1 + 0 * 2]) * c * c - (t[1 + 2 * 2] - t[1 + 0 * 2]) * a * a;
        double top2 = (t[0 + 1 * 2] - t[0 + 0 * 2]) * c * c - (t[0 + 2 * 2] - t[0 + 0 * 2]) * a * a;
        bot = (t[1 + 1 * 2] - t[1 + 0 * 2]) * (t[0 + 2 * 2] - t[0 + 0 * 2])
              - (t[1 + 2 * 2] - t[1 + 0 * 2]) * (t[0 + 1 * 2] - t[0 + 0 * 2]);

        pc[0] = t[0 + 0 * 2] + 0.5 * top1 / bot;
        pc[1] = t[1 + 0 * 2] - 0.5 * top2 / bot;
    }

    public static bool triangle_contains_point_2d(double[] t, double[] p)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_CONTAINS_POINT_2D finds if a point is inside a triangle in 2D.
        //
        //  Discussion:
        //
        //    The routine assumes that the vertices are given in counter clockwise
        //    order.  If the triangle vertices are actually given in clockwise
        //    order, this routine will behave as though the triangle contains
        //    no points whatsoever!
        //
        //    The routine determines if P is "to the right of" each of the lines
        //    that bound the triangle.  It does this by computing the cross product
        //    of vectors from a vertex to its next vertex, and to P.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    07 June 2006
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //    The vertices should be given in counter clockwise order.
        //
        //    Input, double P[2], the point to be checked.
        //
        //    Output, bool TRIANGLE_CONTAINS_POINT_2D, is TRUE if P is inside
        //    the triangle or on its boundary.
        //
    {
        int j;

        for (j = 0; j < 3; j++)
        {
            int k = (j + 1) % 3;
            switch ((p[0] - t[0 + j * 2]) * (t[1 + k * 2] - t[1 + j * 2])
                    - (p[1] - t[1 + j * 2]) * (t[0 + k * 2] - t[0 + j * 2]))
            {
                case > 0.0:
                    return false;
            }
        }

        return true;
    }

    public static double triangle_diameter_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_DIAMETER computes the diameter of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The diameter of a triangle is the diameter of the smallest circle
        //    that can be drawn around the triangle.  At least two of the vertices
        //    of the triangle will intersect the circle, but not necessarily
        //    all three!
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    09 November 2015
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double TRIANGLE_DIAMETER, the diameter of the triangle.
        //
    {
        double diam;
        double s;
        //
        //  Compute the (squares of) the lengths of the sides.
        //
        double a = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2) + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
        double b = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2) + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
        double c = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2) + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));
        switch (a)
        {
            //
            //  Take care of a zero side.
            //
            case 0.0:
                return Math.Sqrt(b);
        }

        switch (b)
        {
            case 0.0:
                return Math.Sqrt(c);
        }
        switch (c)
        {
            case 0.0:
                return Math.Sqrt(a);
        }

        //
        //  Make A the largest.
        //
        if (a < b)
        {
            s = a;
            a = b;
            b = s;
        }

        if (a < c)
        {
            s = a;
            a = c;
            c = s;
        }

        //
        //  If A is very large...
        //
        if (b + c < a)
        {
            diam = Math.Sqrt(a);
        }
        else
        {
            a = Math.Sqrt(a);
            b = Math.Sqrt(b);
            c = Math.Sqrt(c);
            diam = 2.0 * a * b * c / Math.Sqrt((a + b + c) * (-a + b + c)
                                                           * (a - b + c) * (a + b - c));
        }

        return diam;
    }

    public static double[] triangle_edge_length_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_EDGE_LENGTH_2D returns edge lengths of a triangle in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    17 August 2009
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double TRIANGLE_EDGE_LENGTH[3], the length of the edges.
        //
    {
        int j1;

        double[] edge_length = new double[3];

        for (j1 = 0; j1 < 3; j1++)
        {
            int j2 = i4_wrap(j1 + 1, 0, 2);
            edge_length[j1] = Math.Sqrt(Math.Pow(t[0 + j2 * 2] - t[0 + j1 * 2], 2)
                                        + Math.Pow(t[1 + j2 * 2] - t[1 + j1 * 2], 2));
        }

        return edge_length;
    }

    public static void triangle_incircle_2d(double[] t, ref double[] pc, ref double r)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_INCIRCLE_2D computes the inscribed circle of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The inscribed circle of a triangle is the largest circle that can
        //    be drawn inside the triangle.  It is tangent to all three sides,
        //    and the lines from its center to the vertices bisect the angles
        //    made by each vertex.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    03 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Adrian Bowyer, John Woodwark,
        //    A Programmer's Geometry,
        //    Butterworths, 1983.
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double PC[2], *R, the center of the inscribed circle, and its radius.
        //
    {
        double s12 = Math.Sqrt(Math.Pow(t[0 + 1 * 2] - t[0 + 0 * 2], 2)
                               + Math.Pow(t[1 + 1 * 2] - t[1 + 0 * 2], 2));
        double s23 = Math.Sqrt(Math.Pow(t[0 + 2 * 2] - t[0 + 1 * 2], 2)
                               + Math.Pow(t[1 + 2 * 2] - t[1 + 1 * 2], 2));
        double s31 = Math.Sqrt(Math.Pow(t[0 + 0 * 2] - t[0 + 2 * 2], 2)
                               + Math.Pow(t[1 + 0 * 2] - t[1 + 2 * 2], 2));

        double perim = s12 + s23 + s31;

        switch (perim)
        {
            case 0.0:
                r = 0.0;
                pc[0] = t[0 + 0 * 2];
                pc[1] = t[1 + 0 * 2];
                break;
            default:
                pc[0] = (s23 * t[0 + 0 * 2] + s31 * t[0 + 1 * 2] + s12 * t[0 + 2 * 2]) / perim;
                pc[1] = (s23 * t[1 + 0 * 2] + s31 * t[1 + 1 * 2] + s12 * t[1 + 2 * 2]) / perim;

                r = 0.5 * Math.Sqrt(
                    (-s12 + s23 + s31)
                    * (+s12 - s23 + s31)
                    * (+s12 + s23 - s31) / perim);
                break;
        }
    }

    public static int triangle_num ( int n )

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NUM returns the N-th triangular number.
        //
        //  Definition:
        //
        //    The N-th triangular number T(N) is formed by the sum of the first
        //    N ints:
        //
        //      T(N) = sum ( 1 <= I <= N ) I
        //
        //    By convention, T(0) = 0.
        //
        //  Formula:
        //
        //    T(N) = ( N * ( N + 1 ) ) / 2
        //
        //  First Values:
        //
        //     0
        //     1
        //     3
        //     6
        //    10
        //    15
        //    21
        //    28
        //    36
        //    45
        //    55
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    12 October 2012
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int N, the index of the desired number, 
        //    which must be at least 0.
        //
        //    Output, int TRIANGLE_NUM, the N-th triangular number.
        //
    {
        int value = n * ( n + 1 ) / 2;

        return value;
    }
    public static int triangle_orientation_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ORIENTATION_2D determines the orientation of a triangle in 2D.
        //
        //  Discussion:
        //
        //    Three distinct non-colinear points in the plane define a circle.
        //    If the points are visited in the order (x1,y1), (x2,y2), and then
        //    (x3,y3), this motion defines a clockwise or counter clockwise
        //    rotation along the circle.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    04 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, int TRIANGLE_ORIENTATION_2D, reports if the three points lie
        //    clockwise on the circle that passes through them.  The possible
        //    return values are:
        //    0, the points are distinct, noncolinear, and lie counter clockwise
        //    on their circle.
        //    1, the points are distinct, noncolinear, and lie clockwise
        //    on their circle.
        //    2, the points are distinct and colinear.
        //    3, at least two of the points are identical.
        //
    {
        int value = 0;

        if (r8vec_eq(2, t, t, 0 * 2, 1 * 2) ||
            r8vec_eq(2, t, t, 1 * 2, 2 * 2) ||
            r8vec_eq(2, t, t, 2 * 2))
        {
            value = 3;
            return value;
        }

        double det = (t[0 + 0 * 2] - t[0 + 2 * 2]) * (t[1 + 1 * 2] - t[1 + 2 * 2])
                     - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (t[1 + 0 * 2] - t[1 + 2 * 2]);

        value = det switch
        {
            0.0 => 2,
            < 0.0 => 1,
            > 0.0 => 0,
            _ => value
        };

        return value;
    }

    public static void triangle_orthocenter_2d(double[] t, double[] p, ref bool flag)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ORTHOCENTER_2D computes the orthocenter of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The orthocenter is defined as the intersection of the three altitudes
        //    of a triangle.
        //
        //    An altitude of a triangle is the line through a vertex of the triangle
        //    and perpendicular to the opposite side.
        //
        //    In geometry, the orthocenter of a triangle is often symbolized by "H".
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    30 July 2009
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Adrian Bowyer, John Woodwark,
        //    A Programmer's Geometry,
        //    Butterworths, 1983.
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double P[2], the coordinates of the orthocenter of the triangle.
        //
        //    Output, bool *FLAG, is TRUE if the point could not be computed.
        //
    {
        int ival = 0;
        //
        //  Determine a point P23 common to the line through P2 and P3 and
        //  its perpendicular through P1.
        //
        double[] p23 = Line.line_exp_perp_2d(t, t, t, ref flag, p1Index: 1 * 2, p2Index: 2 * 2, p3Index: 0 * 2);

        switch (flag)
        {
            case true:
                p[0] = r8_huge();
                p[1] = r8_huge();
                return;
        }

        //
        //  Determine a point P31 common to the line through P3 and P1 and
        //  its perpendicular through P2.
        //
        double[] p31 = Line.line_exp_perp_2d(t, t, t, ref flag, p1Index: 2 * 2, p2Index: 0 * 2, p3Index: 1 * 2);
        switch (flag)
        {
            case true:
                p[0] = r8_huge();
                p[1] = r8_huge();
                break;
        }

        //
        //  Determine P, the intersection of the lines through P1 and P23, and
        //  through P2 and P31.
        //
        Line.lines_exp_int_2d(t, p23, t, p31, ref ival, ref p, p1Index: 0 * 2, p3Index: 1 * 2);

        if (ival == 1)
        {
            return;
        }

        p[0] = r8_huge();
        p[1] = r8_huge();
        flag = true;
    }

    public static double triangle_quality_2d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_QUALITY_2D: "quality" of a triangle in 2D.
        //
        //  Discussion:
        //
        //    The quality of a triangle is 2 times the ratio of the radius of the inscribed
        //    circle divided by that of the circumscribed circle.  An equilateral
        //    triangle achieves the maximum possible quality of 1.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    30 July 2009
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Adrian Bowyer, John Woodwark,
        //    A Programmer's Geometry,
        //    Butterworths, 1983.
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Output, double TRIANGLE_QUALITY_2D, the quality of the triangle.
        //
    {
        int i;
        //
        //  Compute the length of each side.
        //
        double a = 0.0;
        double b = 0.0;
        double c = 0.0;

        for (i = 0; i < 2; i++)
        {
            a += Math.Pow(t[i + 0 * 2] - t[i + 1 * 2], 2);
            b += Math.Pow(t[i + 1 * 2] - t[i + 2 * 2], 2);
            c += Math.Pow(t[i + 2 * 2] - t[i + 0 * 2], 2);
        }

        a = Math.Sqrt(a);
        b = Math.Sqrt(b);
        c = Math.Sqrt(c);

        double value = (a * b * c) switch
        {
            0.0 => 0.0,
            _ => (-a + b + c) * (a - b + c) * (a + b - c) / (a * b * c)
        };

        return value;
    }

    public static double triangle_point_dist(double[] t, double[] p)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_POINT_DIST: distance ( triangle, point ) in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    01 June 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Input, double P[2], the point which is to be checked.
        //
        //    Output, double TRIANGLE_POINT_DIST, the distance from the point to the triangle.
        //    DIST is zero if the point lies exactly on the triangle.
        //
    {
        double value = Line.segment_point_dist(t, t, p, p1Index: +0 * 2, p2Index: +1 * 2);
        value = Math.Min(value, Line.segment_point_dist(t, t, p, p1Index: +1 * 2, p2Index: +2 * 2));
        value = Math.Min(value, Line.segment_point_dist(t, t, p, p1Index: +2 * 2, p2Index: +0 * 2));

        return value;
    }

    public static void triangle_point_near(double[] t, double[] p, ref double[] pn,
            ref double dist)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_POINT_NEAR computes the nearest triangle point to a point in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    01 June 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Input, double P[2], the point whose nearest neighbor
        //    on the line is to be determined.
        //
        //    Output, double PN[2], the nearest point to P.
        //
        //    Output, double &DIST, the distance from the point to the triangle.
        //
    {
        double dist12 = 0;
        double dist23 = 0;
        double dist31 = 0;
        double tval = 0;
        double[] pn12 = new double[2];
        double[] pn23 = new double[2];
        double[] pn31 = new double[2];
        //
        //  Find the distance to each of the line segments that make up the edges
        //  of the triangle.
        //
        Line.segment_point_near(t, t, p, ref pn12, ref dist12, ref tval, p1Index: +0 * 2, p2Index: +1 * 2);

        Line.segment_point_near(t, t, p, ref pn23, ref dist23, ref tval, p1Index: +1 * 2, p2Index: +2 * 2);

        Line.segment_point_near(t, t, p, ref pn31, ref dist31, ref tval, p1Index: +2 * 2, p2Index: +0 * 2);

        if (dist12 <= dist23 && dist12 <= dist31)
        {
            dist = dist12;
            r8vec_copy(2, pn12, ref pn);
        }
        else if (dist23 <= dist12 && dist23 <= dist31)
        {
            dist = dist23;
            r8vec_copy(2, pn23, ref pn);
        }
        else
        {
            dist = dist31;
            r8vec_copy(2, pn31, ref pn);
        }
    }

    public static void triangle_points_plot(string file_name, double[] node_xy, int node_show,
            int point_num, double[] point_xy, int point_show)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_POINTS_PLOT plots a triangle and some points.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    04 October 2006
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, char *FILE_NAME, the name of the output file.
        //
        //    Input, double NODE_XY[2*3], the coordinates of the nodes
        //    of the triangle.
        //
        //    Input, int NODE_SHOW,
        //   -1, do not show the triangle, or the nodes.
        //    0, show the triangle, do not show the nodes;
        //    1, show the triangle and the nodes;
        //    2, show the triangle, the nodes and number them.
        //
        //    Input, int POINT_NUM, the number of points.
        //
        //    Input, double POINT_XY[2*POINT_NUM], the coordinates of the 
        //    points.
        //
        //    Input, int POINT_SHOW,
        //    0, do not show the points;
        //    1, show the points;
        //    2, show the points and number them.
        //
    {
        int circle_size;
        int delta;
        List<string> file_unit = new();
        int node;
        const int node_num = 3;
        int point;
        int x_ps;
        int x_ps_max = 576;
        int x_ps_max_clip = 594;
        int x_ps_min = 36;
        int x_ps_min_clip = 18;
        int y_ps;
        int y_ps_max = 666;
        int y_ps_max_clip = 684;
        int y_ps_min = 126;
        int y_ps_min_clip = 108;
        //
        //  We need to do some figuring here, so that we can determine
        //  the range of the data, and hence the height and width
        //  of the piece of paper.
        //
        double x_max = -r8_huge();
        for (node = 0; node < node_num; node++)
        {
            if (x_max < node_xy[0 + node * 2])
            {
                x_max = node_xy[0 + node * 2];
            }
        }

        for (point = 0; point < point_num; point++)
        {
            if (x_max < point_xy[0 + point * 2])
            {
                x_max = point_xy[0 + point * 2];
            }
        }

        double x_min = r8_huge();
        for (node = 0; node < node_num; node++)
        {
            if (node_xy[0 + node * 2] < x_min)
            {
                x_min = node_xy[0 + node * 2];
            }
        }

        for (point = 0; point < point_num; point++)
        {
            if (point_xy[0 + point * 2] < x_min)
            {
                x_min = point_xy[0 + point * 2];
            }
        }

        double x_scale = x_max - x_min;

        x_max += 0.05 * x_scale;
        x_min -= 0.05 * x_scale;
        x_scale = x_max - x_min;

        double y_max = -r8_huge();
        for (node = 0; node < node_num; node++)
        {
            if (y_max < node_xy[1 + node * 2])
            {
                y_max = node_xy[1 + node * 2];
            }
        }

        for (point = 0; point < point_num; point++)
        {
            if (y_max < point_xy[1 + point * 2])
            {
                y_max = point_xy[1 + point * 2];
            }
        }

        double y_min = r8_huge();
        for (node = 0; node < node_num; node++)
        {
            if (node_xy[1 + node * 2] < y_min)
            {
                y_min = node_xy[1 + node * 2];
            }
        }

        for (point = 0; point < point_num; point++)
        {
            if (point_xy[1 + point * 2] < y_min)
            {
                y_min = point_xy[1 + point * 2];
            }
        }

        double y_scale = y_max - y_min;

        y_max += 0.05 * y_scale;
        y_min -= 0.05 * y_scale;
        y_scale = y_max - y_min;

        if (x_scale < y_scale)
        {
            delta = (int) r8_nint((x_ps_max - x_ps_min)
                * (y_scale - x_scale) / (2.0 * y_scale));

            x_ps_max -= delta;
            x_ps_min += delta;

            x_ps_max_clip -= delta;
            x_ps_min_clip += delta;

            x_scale = y_scale;
        }
        else if (y_scale < x_scale)
        {
            delta = (int) r8_nint((y_ps_max - y_ps_min)
                * (x_scale - y_scale) / (2.0 * x_scale));

            y_ps_max -= delta;
            y_ps_min += delta;

            y_ps_max_clip -= delta;
            y_ps_min_clip += delta;

            y_scale = x_scale;
        }

        file_unit.Add("%//PS-Adobe-3.0 EPSF-3.0");
        file_unit.Add("%%Creator: triangulation_order3_plot.C");
        file_unit.Add("%%Title: " + file_name + "");
        file_unit.Add("%%Pages: 1");
        file_unit.Add("%%BoundingBox:  "
                      + x_ps_min + "  "
                      + y_ps_min + "  "
                      + x_ps_max + "  "
                      + y_ps_max + "");
        file_unit.Add("%%Document-Fonts: Times-Roman");
        file_unit.Add("%%LanguageLevel: 1");
        file_unit.Add("%%EndComments");
        file_unit.Add("%%BeginProlog");
        file_unit.Add("/inch {72 mul} def");
        file_unit.Add("%%EndProlog");
        file_unit.Add("%%Page: 1 1");
        file_unit.Add("save");
        file_unit.Add("%");
        file_unit.Add("%  Set the RGB line color to very light gray.");
        file_unit.Add("%");
        file_unit.Add("0.900  0.900  0.900 setrgbcolor");
        file_unit.Add("%");
        file_unit.Add("%  Draw a gray border around the page.");
        file_unit.Add("%");
        file_unit.Add("newpath");
        file_unit.Add(x_ps_min + "  "
                               + y_ps_min + "  moveto");
        file_unit.Add(x_ps_max + "  "
                               + y_ps_min + "  lineto");
        file_unit.Add(x_ps_max + "  "
                               + y_ps_max + "  lineto");
        file_unit.Add(x_ps_min + "  "
                               + y_ps_max + "  lineto");
        file_unit.Add(x_ps_min + "  "
                               + y_ps_min + "  lineto");
        file_unit.Add("stroke");
        file_unit.Add("%");
        file_unit.Add("%  Set the RGB color to black.");
        file_unit.Add("%");
        file_unit.Add("0.000  0.000  0.000 setrgbcolor");
        file_unit.Add("%");
        file_unit.Add("%  Set the font and its size.");
        file_unit.Add("%");
        file_unit.Add("/Times-Roman findfont");
        file_unit.Add("0.50 inch scalefont");
        file_unit.Add("setfont");
        file_unit.Add("%");
        file_unit.Add("%  Print a title.");
        file_unit.Add("%");
        file_unit.Add("%  210  702  moveto");
        file_unit.Add("%  (Triangulation)  show");
        file_unit.Add("%");
        file_unit.Add("%  Define a clipping polygon.");
        file_unit.Add("%");
        file_unit.Add("newpath");
        file_unit.Add(x_ps_min_clip + "  "
                                    + y_ps_min_clip + "  moveto");
        file_unit.Add(x_ps_max_clip + "  "
                                    + y_ps_min_clip + "  lineto");
        file_unit.Add(x_ps_max_clip + "  "
                                    + y_ps_max_clip + "  lineto");
        file_unit.Add(x_ps_min_clip + "  "
                                    + y_ps_max_clip + "  lineto");
        file_unit.Add(x_ps_min_clip + "  "
                                    + y_ps_min_clip + "  lineto");
        file_unit.Add("clip newpath");
        switch (node_show)
        {
            //
            //  Draw the triangle.
            //
            case >= 0:
            {
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to red.");
                file_unit.Add("%");
                file_unit.Add("0.900  0.200  0.100 setrgbcolor");
                file_unit.Add("%");
                file_unit.Add("%  Draw the triangle.");
                file_unit.Add("%");

                file_unit.Add("newpath");

                int i;
                for (i = 0; i <= 3; i++)
                {
                    node = i4_wrap(i, 0, 2);

                    x_ps = (int) (
                        ((x_max - node_xy[0 + node * 2]) * x_ps_min
                         + (node_xy[0 + node * 2] - x_min) * x_ps_max)
                        / (x_max - x_min));

                    y_ps = (int) (
                        ((y_max - node_xy[1 + node * 2]) * y_ps_min
                         + (node_xy[1 + node * 2] - y_min) * y_ps_max)
                        / (y_max - y_min));

                    switch (i)
                    {
                        case 0:
                            file_unit.Add(x_ps + "  " + y_ps + "  moveto");
                            break;
                        default:
                            file_unit.Add(x_ps + "  " + y_ps + "  lineto");
                            break;
                    }
                }

                file_unit.Add("stroke");
                break;
            }
        }

        switch (node_show)
        {
            //
            //  Draw the nodes.
            //
            case >= 1:
            {
                circle_size = 5;

                file_unit.Add("%");
                file_unit.Add("%  Draw filled dots at the nodes.");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to blue.");
                file_unit.Add("%");
                file_unit.Add("0.000  0.150  0.750 setrgbcolor");
                file_unit.Add("%");

                for (node = 0; node < 3; node++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - node_xy[0 + node * 2]) * x_ps_min
                         + (node_xy[0 + node * 2] - x_min) * x_ps_max)
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - node_xy[1 + node * 2]) * y_ps_min
                         + (node_xy[1 + node * 2] - y_min) * y_ps_max)
                        / (y_max - y_min));

                    file_unit.Add("newpath  " + x_ps
                                              + "  " + y_ps
                                              + "  " + circle_size
                                              + "  0 360 arc closepath fill");
                }

                break;
            }
        }

        switch (node_show)
        {
            //
            //  Label the nodes.
            //
            case >= 2:
            {
                file_unit.Add("%");
                file_unit.Add("%  Label the nodes:");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to darker blue.");
                file_unit.Add("%");
                file_unit.Add("0.000  0.250  0.850 setrgbcolor");
                file_unit.Add("/Times-Roman findfont");
                file_unit.Add("0.20 inch scalefont");
                file_unit.Add("setfont");
                file_unit.Add("%");

                for (node = 0; node < node_num; node++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - node_xy[0 + node * 2]) * x_ps_min
                         + (+node_xy[0 + node * 2] - x_min) * x_ps_max)
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - node_xy[1 + node * 2]) * y_ps_min
                         + (node_xy[1 + node * 2] - y_min) * y_ps_max)
                        / (y_max - y_min));

                    file_unit.Add("  " + x_ps
                                       + "  " + y_ps + 5
                                       + "  moveto (" + (node + 1) + ") show");
                }

                break;
            }
        }

        circle_size = point_num switch
        {
            //
            //  Draw the points.
            //
            <= 200 => 5,
            <= 500 => 4,
            <= 1000 => 3,
            <= 5000 => 2,
            _ => 1
        };

        switch (point_show)
        {
            case >= 1:
            {
                file_unit.Add("%");
                file_unit.Add("%  Draw filled dots at the points.");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to green.");
                file_unit.Add("%");
                file_unit.Add("0.150  0.750  0.000 setrgbcolor");
                file_unit.Add("%");

                for (point = 0; point < point_num; point++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - point_xy[0 + point * 2]) * x_ps_min
                         + (point_xy[0 + point * 2] - x_min) * x_ps_max)
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - point_xy[1 + point * 2]) * y_ps_min
                         + (point_xy[1 + point * 2] - y_min) * y_ps_max)
                        / (y_max - y_min));

                    file_unit.Add("newpath  " + x_ps
                                              + "  " + y_ps
                                              + "  " + circle_size
                                              + "  0 360 arc closepath fill");
                }

                break;
            }
        }

        switch (point_show)
        {
            //
            //  Label the points.
            //
            case >= 2:
            {
                file_unit.Add("%");
                file_unit.Add("%  Label the point:");
                file_unit.Add("%");
                file_unit.Add("%  Set the RGB color to darker green.");
                file_unit.Add("%");
                file_unit.Add("0.250  0.850  0.000 setrgbcolor");
                file_unit.Add("/Times-Roman findfont");
                file_unit.Add("0.20 inch scalefont");
                file_unit.Add("setfont");
                file_unit.Add("%");

                for (point = 0; point < point_num; point++)
                {
                    x_ps = (int) r8_nint(
                        ((x_max - point_xy[0 + point * 2]) * x_ps_min
                         + (+point_xy[0 + point * 2] - x_min) * x_ps_max)
                        / (x_max - x_min));

                    y_ps = (int) r8_nint(
                        ((y_max - point_xy[1 + point * 2]) * y_ps_min
                         + (point_xy[1 + point * 2] - y_min) * y_ps_max)
                        / (y_max - y_min));

                    file_unit.Add("  " + x_ps
                                       + "  " + y_ps + 5
                                       + "  moveto (" + (point + 1) + ") show");
                }

                break;
            }
        }

        file_unit.Add("%");
        file_unit.Add("restore  showpage");
        file_unit.Add("%");
        file_unit.Add("%  End of page.");
        file_unit.Add("%");
        file_unit.Add("%%Trailer");
        file_unit.Add("%%EOF");

        try
        {
            File.WriteAllLines(file_name, file_unit);
        }
        catch
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_POINTS_PLOT - Fatal error!");
            Console.WriteLine("  Could not open the output EPS file.");
        }

    }

    public static void triangle_element_data_example(int element_num, int element_order,
            int element_att_num, ref int[] element_node, ref double[] element_att)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ELEMENT_DATA_EXAMPLE returns the element information for the example.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int ELEMENT_NUM, the number of elements.
        //
        //    Input, int ELEMENT_ORDER, the order of the elements.
        //
        //    Input, int ELEMENT_ATT_NUM, the number of element attributes.
        //
        //    Output, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
        //    nodes that make up each element.
        //
        //    Output, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
        //    of each element.
        //
    {
        int[] element_node_save =
            {
                1, 2, 6,
                7, 6, 2,
                2, 3, 7,
                8, 7, 3,
                3, 4, 8,
                9, 8, 4,
                4, 5, 9,
                10, 9, 5,
                6, 7, 11,
                12, 11, 7,
                7, 8, 12,
                13, 12, 8,
                8, 9, 13,
                14, 13, 9,
                9, 10, 14,
                15, 14, 10,
                11, 12, 16,
                17, 16, 12,
                12, 13, 17,
                18, 17, 13,
                16, 17, 19,
                20, 19, 17,
                17, 18, 20,
                21, 20, 18
            }
            ;

        i4mat_copy(element_order, element_num, element_node_save, ref element_node);

    }

    public static void triangle_element_data_read(string element_file, int element_num,
            int element_order, int element_att_num, ref int[] element_node,
            ref double[] element_att)

        //*****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ELEMENT_DATA_READ reads the header information from an element file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string ELEMENT_FILE, the name of the file to be read.
        //
        //    Input, int ELEMENT_NUM, the number of elements.
        //
        //    Input, int ELEMENT_ORDER, the order of the elements.
        //
        //    Input, int ELEMENT_ATT_NUM, number of element attributes listed on each 
        //    node record.
        //
        //    Output, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
        //    nodes that make up each element.
        //
        //    Output, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
        //    of each element.
        //
    {
        string[] inputlines;

        int element = -1;

        try
        {
            inputlines = File.ReadAllLines(element_file);
        }
        catch
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_ELEMENT_DATA_READ - Fatal error!");
            Console.WriteLine("  Could not open file.");
            return;
        }

        foreach (string input in inputlines)
        {
            string[] tokens = Helpers.splitStringByWhitespace(input);
            switch (element)
            {
                /*
            Read, but ignore, dimension line.
            */
                case -1:
                    break;
                default:
                {
                    int index = 0;
                    int ival = Convert.ToInt32(tokens[index]);
                    index++;

                    int i;
                    for (i = 0; i < element_order; i++)
                    {
                        ival = Convert.ToInt32(tokens[index]);
                        index++;
                        element_node[i + element * element_order] = ival;
                    }

                    for (i = 0; i < element_att_num; i++)
                    {
                        double value = Convert.ToInt32(tokens[index]);
                        index++;
                        element_att[i + element * element_att_num] = value;
                    }

                    break;
                }
            }

            element += 1;

            if (element_num <= element)
            {
                break;
            }
        }
    }

    public static void triangle_element_size_example(ref int element_num, ref int element_order,
            ref int element_att_num)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ELEMENT_SIZE_EXAMPLE returns the element size information for the example.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Output, int *ELEMENT_NUM, the number of elements.
        //
        //    Output, int *ELEMENT_ORDER, the order of the elements.
        //
        //    Output, int *ELEMENT_ATT_NUM, the number of element attributes.
        //
    {
        element_num = 24;
        element_order = 3;
        element_att_num = 0;
    }

    public static void triangle_element_size_read(string element_file, ref int element_num,
            ref int element_order, ref int element_att_num)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ELEMENT_SIZE_READ reads the header information from an element file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string ELEMENT_FILE, the name of the file to be read.
        //
        //    Output, int *ELEMENT_NUM, the number of elements.
        //
        //    Output, int *ELEMENT_ORDER, the order of the elements.
        //
        //    Output, int *ELEMENT_ATT_NUM, the number of element attributes.
        //
    {

        try
        {
            string input = File.ReadAllLines(element_file)[0];
            string[] tokens = Helpers.splitStringByWhitespace(input);
            element_num = Convert.ToInt32(tokens[0]);
            element_order = Convert.ToInt32(tokens[1]);
            element_att_num = Convert.ToInt32(tokens[2]);
        }
        catch
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_ELEMENT_SIZE_READ - Fatal error!");
            Console.WriteLine("  Could not open file.");
        }
    }

    public static void triangle_element_write(string element_file, int element_num,
            int element_order, int element_att_num, int[] element_node,
            double[] element_att)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ELEMENT_WRITE writes a TRIANGLE ".ele" file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string ELEMENT_FILE, the name of the file to be written.
        //
        //    Input, int ELEMENT_NUM, the number of elements.
        //
        //    Input, int ELEMENT_ORDER, the order of the elements.
        //
        //    Input, int ELEMENT_ATT_NUM, the number of element attributes.
        //
        //    Input, int ELEMENT_NODE[ELEMENT_ORDER*ELEMENT_NUM], the indices of the
        //    nodes that make up each element.
        //
        //    Input, double ELEMENT_ATT[ELEMENT_ATT_NUM*ELEMENT_NUM], the attributes
        //    of each element.
        //
    {
        int element;
        List<string> output = new()
        {
            "  " + element_num
                 + "  " + element_order
                 + "  " + element_att_num + ""
        };


        for (element = 0; element < element_num; element++)
        {
            string tmp = "  " + (element + 1);
            int order;
            for (order = 0; order < element_order; order++)
            {
                tmp += "  " + element_node[order + element * element_order];
            }

            int att;
            for (att = 0; att < element_att_num; att++)
            {
                tmp += element_att[att + element * element_att_num];
            }

            output.Add(tmp);
        }

        File.WriteAllLines(element_file, output);
    }

    public static void triangle_node_data_example(int node_num, int node_dim, int node_att_num,
            int node_marker_num, ref double[] node_coord, ref double[] node_att,
            ref int[] node_marker)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NODE_DATA_EXAMPLE returns the node information for the example.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int NODE_NUM, the number of nodes.
        //
        //    Input, int NODE_DIM, the spatial dimension.
        //
        //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
        //    node record.
        //
        //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
        //    boundary marker value.
        //
        //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
        //
        //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
        //
        //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
        //
    {
        double[] node_coord_save =
            {
                0.0, 0.0,
                1.0, 0.0,
                2.0, 0.0,
                3.0, 0.0,
                4.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                2.0, 1.0,
                3.0, 1.0,
                4.0, 1.0,
                0.0, 2.0,
                1.0, 2.0,
                2.0, 2.0,
                3.0, 2.0,
                4.0, 2.0,
                0.0, 3.0,
                1.0, 3.0,
                2.0, 3.0,
                0.0, 4.0,
                1.0, 4.0,
                2.0, 4.0
            }
            ;
        int[] node_marker_save =
            {
                1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
                1, 0, 0, 1, 1, 1, 0, 1, 1, 1,
                1
            }
            ;

        r8mat_copy(2, 21, node_coord_save, ref node_coord);
        i4vec_copy(21, node_marker_save, ref node_marker);

    }

    public static void triangle_node_data_read(string node_file, int node_num, int node_dim,
            int node_att_num, int node_marker_num, ref double[] node_coord, ref double[] node_att,
            ref int[] node_marker)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NODE_HEADER_READ reads the header information from a node file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string NODE_FILE, the name of the node file to be read.
        //
        //    Input, int NODE_NUM, the number of nodes.
        //
        //    Input, int NODE_DIM, the spatial dimension.
        //
        //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
        //    node record.
        //
        //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
        //    boundary marker value.
        //
        //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
        //
        //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
        //
        //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
        //
    {
        string[] inputlines;

        int node = -1;

        try
        {
            inputlines = File.ReadAllLines(node_file);
        }
        catch
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_NODE_DATA_READ - Fatal error!");
            Console.WriteLine("  Could not open file.");
            return;
        }

        foreach (string input in inputlines)
        {
            string[] tokens = Helpers.splitStringByWhitespace(input);
            switch (node)
            {
                //
                //  Read, but ignore, dimension line.
                //
                case -1:
                    break;
                default:
                {
                    int index = 0;
                    int ival = Convert.ToInt32(tokens[index]);
                    index++;

                    int i;
                    double value = 0;
                    for (i = 0; i < node_dim; i++)
                    {
                        value = Convert.ToInt32(tokens[index]);
                        index++;
                        node_coord[i + node * node_dim] = value;
                    }

                    for (i = 0; i < node_att_num; i++)
                    {
                        value = Convert.ToInt32(tokens[index]);
                        index++;
                        node_att[i + node * node_att_num] = value;
                    }

                    for (i = 0; i < node_marker_num; i++)
                    {
                        ival = Convert.ToInt32(tokens[index]);
                        index++;
                        node_marker[i + node * node_marker_num] = ival;
                    }

                    break;
                }
            }

            node += 1;

            if (node_num <= node)
            {
                break;
            }
        }
    }

    public static void triangle_node_size_example(ref int node_num, ref int node_dim,
            ref int node_att_num, ref int node_marker_num)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NODE_SIZE_EXAMPLE returns the sizes of node information for the example.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Output, int *NODE_NUM, the number of nodes.
        //
        //    Output, int *NODE_DIM, the spatial dimension.
        //
        //    Output, int *NODE_ATT_NUM, number of node attributes listed on each 
        //    node record.
        //
        //    Output, int *NODE_MARKER_NUM, 1 if every node record includes a final
        //    boundary marker value.
        //
    {
        node_num = 21;
        node_dim = 2;
        node_att_num = 0;
        node_marker_num = 1;
    }

    public static void triangle_node_size_read(string node_file, ref int node_num, ref int node_dim,
            ref int node_att_num, ref int node_marker_num)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NODE_SIZE_READ reads the header information from a node file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string NODE_FILE, the name of the node file to be read.
        //
        //    Output, int *NODE_NUM, the number of nodes.
        //
        //    Output, int *NODE_DIM, the spatial dimension.
        //
        //    Output, int *NODE_ATT_NUM, number of node attributes listed on each 
        //    node record.
        //
        //    Output, int *NODE_MARKER_NUM, 1 if every node record includes a final
        //    boundary marker value.
        //
    {
        string input = File.ReadAllLines(node_file)[0];

        string[] tokens = Helpers.splitStringByWhitespace(input);

        node_num = Convert.ToInt32(tokens[0]);
        node_dim = Convert.ToInt32(tokens[1]);
        node_att_num = Convert.ToInt32(tokens[2]);
        node_marker_num = Convert.ToInt32(tokens[3]);

    }

    public static void triangle_node_write(string node_file, int node_num, int node_dim,
            int node_att_num, int node_marker_num, ref double[] node_coord,
            ref double[] node_att, ref int[] node_marker)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_NODE_WRITE writes a TRIANGLE ".node" file.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    07 December 2010
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string NODE_FILE, the name of the node file to be written.
        //
        //    Input, int NODE_NUM, the number of nodes.
        //
        //    Input, int NODE_DIM, the spatial dimension.
        //
        //    Input, int NODE_ATT_NUM, number of node attributes listed on each 
        //    node record.
        //
        //    Input, int NODE_MARKER_NUM, 1 if every node record includes a final
        //    boundary marker value.
        //
        //    Output, double NODE_COORD[NODE_DIM*NODE_NUM], the nodal coordinates.
        //
        //    Output, double NODE_ATT[NODE_ATT_NUM*NODE_NUM], the nodal attributes.
        //
        //    Output, int NODE_MARKER[NODE_MARKER_NUM*NODE_NUM], the node markers.
        //
    {
        int node;
        List<string> output = new()
        {
            "  " + node_num
                 + "  " + node_dim
                 + "  " + node_att_num
                 + "  " + node_marker_num + ""
        };

        for (node = 0; node < node_num; node++)
        {
            string tmp = "  " + (node + 1);
            int dim;
            for (dim = 0; dim < node_dim; dim++)
            {
                tmp += "  " + node_coord[dim + node * node_dim];
            }

            int att;
            for (att = 0; att < node_att_num; att++)
            {
                tmp += "  " + node_att[att + node * node_att_num];
            }

            switch (node_marker_num)
            {
                case 1:
                    tmp += "  " + node_marker[node];
                    break;
            }

            output.Add(tmp);
        }

        File.WriteAllLines(node_file, output);

    }

    public static double[] triangle_xsi_to_xy(double[] t, double[] xsi)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_XSI_TO_XY converts from barycentric to XY coordinates in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    04 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Input, double XSI[3], the barycentric coordinates of a point.
        //
        //    Output, double TRIANGLE_XSI_TO_XY[2], the Cartesian coordinates of the point.
        //
    {
        double[] p = new double[2];

        p[0] = xsi[0] * t[0 + 0 * 2] + xsi[1] * t[0 + 1 * 2] + xsi[2] * t[0 + 2 * 2];
        p[1] = xsi[0] * t[1 + 0 * 2] + xsi[1] * t[1 + 1 * 2] + xsi[2] * t[1 + 2 * 2];

        return p;
    }

    public static double[] triangle_xy_to_xsi(double[] t, double[] p)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_XY_TO_XSI converts from XY to barycentric in 2D.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    04 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[2*3], the triangle vertices.
        //
        //    Input, double P[2], the XY coordinates of a point.
        //
        //    Output, double TRIANGLE_XY_TO_XSI[3], the barycentric coordinates of the point.
        //
    {
        double[] xsi = new double[3];

        double det = (t[0 + 0 * 2] - t[0 + 2 * 2]) * (t[1 + 1 * 2] - t[1 + 2 * 2])
                     - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (t[1 + 0 * 2] - t[1 + 2 * 2]);

        xsi[0] = ((t[1 + 1 * 2] - t[1 + 2 * 2]) * (p[0] - t[0 + 2 * 2])
                  - (t[0 + 1 * 2] - t[0 + 2 * 2]) * (p[1] - t[1 + 2 * 2])) / det;

        xsi[1] = (-(t[1 + 0 * 2] - t[1 + 2 * 2]) * (p[0] - t[0 + 2 * 2])
                  + (t[0 + 0 * 2] - t[0 + 2 * 2]) * (p[1] - t[1 + 2 * 2])) / det;

        xsi[2] = 1.0 - xsi[0] - xsi[1];

        return xsi;
    }

    public static void triangle_svg(string plot_filename, double[] t, int p_num, double[] p)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_SVG plots a triangle and points in SVG format.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    21 April 2014
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, string PLOT_FILENAME, the name of the output file.
        //
        //    Input, double T[2*3], points forming a triangle.
        //
        //    Input, int P_NUM, the number of points.
        //
        //    Input, double P[2*P_NUM], the points.
        //
    {
        int i4;
        int i4_max;
        int j;
        int j4;
        int j4_max;
        List<string> output = new();
        //
        //  Determine SCALE, the maximum data range.
        //
        double x_max = p[0 + 0 * 2];
        double x_min = p[0 + 0 * 2];
        for (j = 0; j < p_num; j++)
        {
            x_max = Math.Max(x_max, p[0 + j * 2]);
            x_min = Math.Min(x_min, p[0 + j * 2]);
        }

        for (j = 0; j < 3; j++)
        {
            x_max = Math.Max(x_max, t[0 + j * 2]);
            x_min = Math.Min(x_min, t[0 + j * 2]);
        }

        double x_scale = x_max - x_min;
        x_max += 0.05 * x_scale;
        x_min -= 0.05 * x_scale;
        x_scale = x_max - x_min;

        double y_max = p[1 + 0 * 2];
        double y_min = p[1 + 0 * 2];
        for (j = 0; j < p_num; j++)
        {
            y_max = Math.Max(y_max, p[1 + j * 2]);
            y_min = Math.Min(y_min, p[1 + j * 2]);
        }

        for (j = 0; j < 3; j++)
        {
            y_max = Math.Max(y_max, t[1 + j * 2]);
            y_min = Math.Min(y_min, t[1 + j * 2]);
        }

        double y_scale = y_max - y_min;
        y_max += 0.05 * y_scale;
        y_min -= 0.05 * y_scale;
        y_scale = y_max - y_min;

        const int i4_min = 1;
        const int j4_min = 1;
        if (x_scale < y_scale)
        {
            i4_max = (int) (0.5 + 500.0 * x_scale / y_scale);
            j4_max = 500;
        }
        else
        {
            i4_max = 500;
            j4_max = (int) (0.5 + 500.0 * y_scale / x_scale);
        }

        //
        //  Write that junk.
        //
        output.Add("<?xml version = \"1.0\" standalone=\"no\"?>");
        output.Add("");
        output.Add("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"");
        output.Add("  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">");
        output.Add("");
        output.Add("<svg");
        output.Add("  width=\"" + i4_max + "\"");
        output.Add("  height=\"" + j4_max + "\"");
        output.Add("  viewbox=\"" + i4_min
                                  + "," + j4_min
                                  + "," + i4_max
                                  + "," + j4_max + "\"");
        output.Add("  xmlns=\"http://www.w3.org/2000/svg\"");
        output.Add("  version=\"1.1\">");
        output.Add("  <desc>");
        output.Add("    Triangulation created by triangle_svg.c");
        output.Add("  </desc>");
        //
        //  Draw the triangle.
        //
        output.Add("  <polygon");
        output.Add("    fill=\"pink\"");
        output.Add("    stroke=\"black\"");
        output.Add("    stroke-width=\"2\"");
        output.Add("    points=\"");

        for (j = 0; j < 3; j++)
        {
            i4 = r8_to_i4(x_min, x_max, t[0 + j * 2], i4_min, i4_max);
            j4 = r8_to_i4(y_max, y_min, t[1 + j * 2], j4_min, j4_max);
            output.Add("      " + i4 + "," + j4 + "");
        }

        output.Add("  \" />");
        //
        //  Draw points.
        //
        for (j = 0; j < p_num; j++)
        {
            i4 = r8_to_i4(x_min, x_max, p[0 + j * 2], i4_min, i4_max);
            j4 = r8_to_i4(y_max, y_min, p[1 + j * 2], j4_min, j4_max);
            const int r = 5;

            output.Add("  <circle");
            output.Add("    cx=\"" + i4 + "\"");
            output.Add("    cy=\"" + j4 + "\"");
            output.Add("    r=\"" + r + "\"");
            output.Add("    fill=\"blue\"");
            output.Add("    stroke=\"black\"");
            output.Add("    stroke-width=\"2\"");
            output.Add("  />");
        }

        //
        //  End of plot.
        //
        output.Add("</svg>");

        File.WriteAllLines(plot_filename, output);

        Console.WriteLine("");
        Console.WriteLine("  Graphics data written to file \"" + plot_filename + "\"");
    }

    public static void triangle_angles_3d(double[] t, ref double[] angle, int angleIndex = 0)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_ANGLES_3D computes the angles of a triangle in 3D.
        //
        //  Discussion:
        //
        //    The law of cosines is used:
        //
        //      C * C = A * A + B * B - 2 * A * B * COS ( GAMMA )
        //
        //    where GAMMA is the angle opposite side C.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    30 July 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double T[3*3], the triangle vertices.
        //
        //    Output, double ANGLE[3], the angles opposite
        //    sides P1-P2, P2-P3 and P3-P1, in radians.
        //
    {
        double a = Math.Sqrt(Math.Pow(t[0 + 1 * 3] - t[0 + 0 * 3], 2)
                             + Math.Pow(t[1 + 1 * 3] - t[1 + 0 * 3], 2)
                             + Math.Pow(t[2 + 1 * 3] - t[2 + 0 * 3], 2));

        double b = Math.Sqrt(Math.Pow(t[0 + 2 * 3] - t[0 + 1 * 3], 2)
                             + Math.Pow(t[1 + 2 * 3] - t[1 + 1 * 3], 2)
                             + Math.Pow(t[2 + 2 * 3] - t[2 + 1 * 3], 2));

        double c = Math.Sqrt(Math.Pow(t[0 + 0 * 3] - t[0 + 2 * 3], 2)
                             + Math.Pow(t[1 + 0 * 3] - t[1 + 2 * 3], 2)
                             + Math.Pow(t[2 + 0 * 3] - t[2 + 2 * 3], 2));
        switch (a)
        {
            //
            //  Take care of a ridiculous special case.
            //
            case 0.0 when b == 0.0 && c == 0.0:
                angle[angleIndex + 0] = 2.0 * Math.PI / 3.0;
                angle[angleIndex + 1] = 2.0 * Math.PI / 3.0;
                angle[angleIndex + 2] = 2.0 * Math.PI / 3.0;
                return;
        }

        if (c == 0.0 || a == 0.0)
        {
            angle[angleIndex + 0] = Math.PI;
        }
        else
        {
            angle[angleIndex + 0] = r8_acos((c * c + a * a - b * b) / (2.0 * c * a));
        }

        if (a == 0.0 || b == 0.0)
        {
            angle[angleIndex + 1] = Math.PI;
        }
        else
        {
            angle[angleIndex + 1] = r8_acos((a * a + b * b - c * c) / (2.0 * a * b));
        }

        if (b == 0.0 || c == 0.0)
        {
            angle[angleIndex + 2] = Math.PI;
        }
        else
        {
            angle[angleIndex + 2] = r8_acos((b * b + c * c - a * a) / (2.0 * b * c));
        }
    }

    public static double triangle_area_3d(double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_AREA_3D computes the area of a triangle in 3D.
        //
        //  Discussion:
        //
        //    This routine uses the fact that the norm of the cross product vector
        //    is the area of the parallelogram they form.  The triangle they
        //    form has half that area.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    17 October 2005
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Reference:
        //
        //    Adrian Bowyer, John Woodwark,
        //    A Programmer's Geometry,
        //    Butterworths, 1983.
        //
        //  Parameters:
        //
        //    Input, double T[3*3], the vertices of the triangle.
        //
        //    Output, double TRIANGLE_AREA_3D, the area of the triangle.
        //
    {
        int i;
        //
        //  Compute the cross product vector.
        //
        double[] cross = new double[3];

        cross[0] = (t[1 + 1 * 3] - t[1 + 0 * 3])
                   * (t[2 + 2 * 3] - t[2 + 0 * 3])
                   - (t[2 + 1 * 3] - t[2 + 0 * 3])
                   * (t[1 + 2 * 3] - t[1 + 0 * 3]);

        cross[1] = (t[2 + 1 * 3] - t[2 + 0 * 3])
                   * (t[0 + 2 * 3] - t[0 + 0 * 3])
                   - (t[0 + 1 * 3] - t[0 + 0 * 3])
                   * (t[2 + 2 * 3] - t[2 + 0 * 3]);

        cross[2] = (t[0 + 1 * 3] - t[0 + 0 * 3])
                   * (t[1 + 2 * 3] - t[1 + 0 * 3])
                   - (t[1 + 1 * 3] - t[1 + 0 * 3])
                   * (t[0 + 2 * 3] - t[0 + 0 * 3]);

        double area = 0.0;
        for (i = 0; i < 3; i++)
        {
            area += Math.Pow(cross[i], 2);
        }

        area = 0.5 * Math.Sqrt(area);

        return area;
    }

    public static double triangle_area(double[] vert1, double[] vert2, double[] vert3)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_AREA returns the area of a triangle.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU GPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Hong Xiao, Zydrunas Gimbutas,
        //    A numerical algorithm for the construction of efficient quadrature
        //    rules in two and higher dimensions,
        //    Computers and Mathematics with Applications,
        //    Volume 59, 2010, pages 663-676.
        //
        //  Parameters:
        //
        //    Input, double VERT1[2], VERT2[2], VERT3[2], the vertices of
        //    the triangle.
        //
        //    Output, double TRIANGLE_AREA, the area of the triangle.
        //
    {
        double value = 0.5 *
                       (
                           (vert2[0] - vert1[0]) * (vert3[1] - vert1[1])
                           - (vert3[0] - vert1[0]) * (vert2[1] - vert1[1])
                       );

        return value;
    }

    public static int triangle_lower_to_i4(int i, int j)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_LOWER_TO_I4 converts a lower triangular coordinate to an integer.
        //
        //  Discussion:
        //
        //    Triangular coordinates are handy when storing a naturally triangular
        //    array (such as the lower half of a matrix) in a linear array.
        //
        //    Thus, for example, we might consider storing
        //
        //    (0,0)
        //    (1,0) (1,1)
        //    (2,0) (2,1) (2,2)
        //    (3,0) (3,1) (3,2) (3,3)
        //
        //    as the linear array
        //
        //    (0,0) (1,0) (1,1) (2,0) (2,1) (2,2) (3,0) (3,1) (3,2) (3,3)
        //
        //    Here, the quantities in parenthesis represent the natural row and
        //    column indices of a single number when stored in a rectangular array.
        //
        //    Thus, our goal is, given the row I and column J of the data,
        //    to produce the value K which indicates its position in the linear
        //    array.
        //
        //    The triangular numbers are the indices associated with the
        //    diagonal elements of the original array, T(0,0), T(1,1), T(2,2), 
        //    T(3,3) and so on.
        //
        //    The formula is:
        //
        //      K = J + ( ( I * ( I + 1 ) ) / 2
        //
        //  Example:
        //
        //    I  J  K
        //
        //    0  0  0
        //    1  0  1
        //    1  1  2
        //    2  0  3
        //    2  1  4
        //    2  2  5
        //    3  0  6
        //    3  1  7
        //    3  2  8
        //    3  3  9
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    18 January 2009
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int I, J, the row and column indices.  I and J must
        //    be nonnegative, and J must not be greater than I.
        //
        //    Output, int TRIANGLE_LOWER_TO_I4, the linear index of the (I,J) element.
        //
    {
        switch (i)
        {
            case < 0:
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
                Console.WriteLine("  I < 0.");
                Console.WriteLine("  I = " + i + "");
                return 1;
        }

        switch (j)
        {
            case < 0:
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
                Console.WriteLine("  J < 0.");
                Console.WriteLine("  J = " + j + "");
                return 1;
        }
        if (i < j)
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_LOWER_TO_I4 - Fatal error!");
            Console.WriteLine("  I < J.");
            Console.WriteLine("  I = " + i + "");
            Console.WriteLine("  J = " + j + "");
            return 1;
        }

        int value = j + i * (i + 1) / 2;

        return value;
    }

    public static int triangle_upper_to_i4(int i, int j)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_UPPER_TO_I4 converts an upper triangular coordinate to an integer.
        //
        //  Discussion:
        //
        //    Triangular coordinates are handy when storing a naturally triangular
        //    array (such as the upper half of a matrix) in a linear array.
        //
        //    Thus, for example, we might consider storing
        //
        //    (0,0) (0,1) (0,2) (0,3)
        //          (1,1) (1,2) (1,3)
        //                (2,2) (2,3)
        //                      (3,3)
        //
        //    as the linear array
        //
        //    (0,0) (0,1) (1,1) (0,2) (1,2) (2,2) (0,3) (1,3) (2,3) (3,3)
        //
        //    Here, the quantities in parenthesis represent the natural row and
        //    column indices of a single number when stored in a rectangular array.
        //
        //    Thus, our goal is, given the row I and column J of the data,
        //    to produce the value K which indicates its position in the linear
        //    array.
        //
        //    The triangular numbers are the indices associated with the
        //    diagonal elements of the original array, T(0,0), T(1,1), T(2,2), 
        //    T(3,3) and so on.
        //
        //    The formula is:
        //
        //      K = I + ( ( J * ( J + 1 ) ) / 2
        //
        //  Example:
        //
        //    I  J  K
        //
        //    0  0  0
        //    0  1  1
        //    1  1  2
        //    0  2  3
        //    1  2  4
        //    2  2  5
        //    0  3  6
        //    1  3  7
        //    2  3  8
        //    3  3  9
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license. 
        //
        //  Modified:
        //
        //    23 March 2017
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, int I, J, the row and column indices.  I and J must
        //    be nonnegative, and I must not be greater than J.
        //
        //    Output, int TRIANGLE_UPPER_TO_I4, the linear index of the (I,J) element.
        //
    {
        switch (i)
        {
            case < 0:
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
                Console.WriteLine("  I < 0.");
                Console.WriteLine("  I = " + i + "");
                return 1;
        }

        switch (j)
        {
            case < 0:
                Console.WriteLine("");
                Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
                Console.WriteLine("  J < 0.");
                Console.WriteLine("  J = " + j + "");
                return 1;
        }
        if (j < i)
        {
            Console.WriteLine("");
            Console.WriteLine("TRIANGLE_UPPER_TO_I4 - Fatal error!");
            Console.WriteLine("  J < I.");
            Console.WriteLine("  I = " + i + "");
            Console.WriteLine("  J = " + j + "");
            return 1;
        }

        int value = i + j * (j + 1) / 2;

        return value;
    }

    public static double[] triangle_to_ref(double[] tvert1, double[] tvert2,
            double[] tvert3, double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_TO_REF maps points from any triangle to the reference triangle.
        //
        //  Discussion:
        //
        //    The reference triangle has vertices:
        //
        //      ( -1, -1/sqrt(3) )
        //      ( +1, -1/sqrt(3) )
        //      (  0, +2/sqrt(3) )
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
        //    of the vertices of the triangle.  These vertices will be taken
        //    to be the images of (0,0), (1,0) and (0,1) respectively.
        //
        //    Input, double T[2], the coordinates of a point in the triangle.
        //
        //    Output, double TRIANGLE_TO_REF[2], the coordinates of a point in the
        //    reference triangle.
        //
    {
        double[] rvert1 = new double[2];
        double[] rvert2 = new double[2];
        double[] rvert3 = new double[2];

        double[] s = triangle_to_simplex(tvert1, tvert2, tvert3, t);

        rvert1[0] = -1.0;
        rvert1[1] = -1.0 / Math.Sqrt(3.0);
        rvert2[0] = +1.0;
        rvert2[1] = -1.0 / Math.Sqrt(3.0);
        rvert3[0] = 0.0;
        rvert3[1] = 2.0 / Math.Sqrt(3.0);

        double[] r = SimplexNS.Simplex.simplex_to_triangle(rvert1, rvert2, rvert3, s);

        return r;
    }

    public static double[] triangle_to_simplex(double[] tvert1, double[] tvert2,
            double[] tvert3, double[] t)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANGLE_TO_SIMPLEX maps points from any triangle to the simplex.
        //
        //  Discussion:
        //
        //    The simplex has vertices:
        //
        //      (  0, 0 )
        //      (  1, 0 )
        //      (  0, 1 )
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
        //    of the vertices of the triangle.  These vertices will be taken
        //    to be the images of (0,0), (1,0) and (0,1) respectively.
        //
        //    Input, double T[2]), the coordinates of a point in the triangle.
        //
        //    Output, double TRIANGLE_TO_SIMPLEX[2], the coordinates of the
        //    point in the simplex.
        //
    {
        double[] s = new double[2];

        s[0] = ((tvert3[1] - tvert1[1]) * (t[0] - tvert1[0])
                - (tvert3[0] - tvert1[0]) * (t[1] - tvert1[1]))
               / ((tvert3[1] - tvert1[1]) * (tvert2[0] - tvert1[0])
                  - (tvert3[0] - tvert1[0]) * (tvert2[1] - tvert1[1]));

        s[1] = ((tvert2[0] - tvert1[0]) * (t[1] - tvert1[1])
                - (tvert2[1] - tvert1[1]) * (t[0] - tvert1[0]))
               / ((tvert3[1] - tvert1[1]) * (tvert2[0] - tvert1[0])
                  - (tvert3[0] - tvert1[0]) * (tvert2[1] - tvert1[1]));

        return s;
    }

    public static void trianmap(int numnodes, double[] vert1, double[] vert2, double[] vert3,
            ref double[] rnodes, ref double[] whts)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIANMAP maps rules from the reference triangle to the user triangle.
        //
        //  Discussion:
        //
        //    This routine maps the quadrature nodes on the reference
        //    triangle into a user-defined triangle specified by its vertices.
        //
        //    The weights are rescaled accordingly, so that
        //    the resulting quadrature will integrate correctly constants, i.e.
        //    the sum of the weights is the area of the user-defined triangle.
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU GPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Hong Xiao, Zydrunas Gimbutas,
        //    A numerical algorithm for the construction of efficient quadrature
        //    rules in two and higher dimensions,
        //    Computers and Mathematics with Applications,
        //    Volume 59, 2010, pages 663-676.
        //
        //  Parameters:
        //
        //    Input, int NUMNODES, the number of nodes.
        //
        //    Input, double VERT1[2], VERT2[2], VERT3[2], the vertices of
        //    the triangle on which the quadrature rule is to be constructed.
        //
        //    Input/output, double RNODES[2*NUMNODES], the nodes.
        //
        //    Input/output, double WHTS[NUMNODES], the weights.
        //
    {
        int j;
        double u = 0;
        double v = 0;

        double area = Math.Abs(triangle_area(vert1, vert2, vert3));

        double scale = r8vec_sum(numnodes, whts);

        scale = area / scale;

        for (j = 0; j < numnodes; j++)
        {
            double x = rnodes[0 + j * 2];
            double y = rnodes[1 + j * 2];
            triasimp(x, y, ref u, ref v);
            x = (vert2[0] - vert1[0]) * u
                + (vert3[0] - vert1[0]) * v + vert1[0];
            y = (vert2[1] - vert1[1]) * u
                + (vert3[1] - vert1[1]) * v + vert1[1];
            rnodes[0 + j * 2] = x;
            rnodes[1 + j * 2] = y;
            whts[j] *= scale;
        }

    }

    public static void triasimp(double x, double y, ref double uout, ref double vout)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    TRIASIMP maps a point from the reference triangle to the simplex.
        //
        //  Discussion:
        //
        //    Map the reference triangle with vertices
        //      (-1,-1/sqrt(3)), (1,-1/sqrt(3)), (0,2/sqrt(3))
        //    to the simplex with vertices
        //      (0,0), (1,0), (0,1).
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU GPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    Original FORTRAN77 version by Hong Xiao, Zydrunas Gimbutas.
        //    C++ version by John Burkardt.
        //
        //  Reference:
        //
        //    Hong Xiao, Zydrunas Gimbutas,
        //    A numerical algorithm for the construction of efficient quadrature
        //    rules in two and higher dimensions,
        //    Computers and Mathematics with Applications,
        //    Volume 59, 2010, pages 663-676.
        //
        //  Parameters:
        //
        //    Input, double X, Y, the coordinates of a point in the
        //    reference triangle.
        //
        //    Output, double &UOUT, &VOUT, the coordinates of the corresponding
        //    point in the simplex.
        //
    {
        double scale = 1.0 / Math.Sqrt(3.0);

        uout = 0.5 * (x + 1.0) - 0.5 * scale * (y + scale);
        vout = 1.0 * scale * (y + scale);

    }

    public static double[] ref_to_koorn(double[] r)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    REF_TO_KOORN maps points from the reference to Koornwinder's triangle.
        //
        //  Discussion:
        //
        //    The reference triangle has vertices:
        //
        //      ( -1, -1/sqrt(3) )
        //      ( +1, -1/sqrt(3) )
        //      (  0, +2/sqrt(3) )
        //
        //    Koornwinder's triangle has vertices:
        //
        //      ( -1, -1 )
        //      ( +1, -1 )
        //      ( -1, +1 )
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double R[2], the coordinates of a point in the
        //    reference triangle.
        //
        //    Output, double REF_TO_KOORN[2], the coordinates of the point in
        //    the Koornwinder triangle.
        //
    {
        double s3 = Math.Sqrt ( 3.0 );
        double s6 = Math.Sqrt ( 6.0 );

        const double a10 = - 0.5;
        const double a11 = 1.0;
        double a12 = - 1.0 / s3;
        double a13 = - 1.0 / s6;

        const double a20 = - 0.5;
        double a22 = 2.0 / s3;
        double a23 = - 1.0 / s6;

        const double a30 = - 0.5;
        double a33 = 0.5 * s6;

        double[] u = new double[3];

        u[0] = a10 + a11 * r[0] + a12 * r[1] + a13 * r[2];
        u[1] = a20 +              a22 * r[1] + a23 * r[2];
        u[2] = a30 +                           a33 * r[2];

        return u;
    }

    public static double[] ref_to_triangle(double[] tvert1, double[] tvert2, double[] tvert3,
            double[] r)

        //****************************************************************************80
        //
        //  Purpose:
        //
        //    REF_TO_TRIANGLE maps points from the reference triangle to a triangle.
        //
        //  Discussion:
        //
        //    The reference triangle has vertices:
        //
        //      ( -1, -1/sqrt(3) )
        //      ( +1, -1/sqrt(3) )
        //      (  0, +2/sqrt(3) )
        //
        //  Licensing:
        //
        //    This code is distributed under the GNU LGPL license.
        //
        //  Modified:
        //
        //    30 June 2014
        //
        //  Author:
        //
        //    John Burkardt
        //
        //  Parameters:
        //
        //    Input, double TVERT1[2], TVERT2[2], TVERT3[2], the coordinates
        //    of the vertices of the triangle.  These vertices will be taken
        //    to be the images of (0,0), (1,0) and (0,1) respectively.
        //
        //    Input, double R[2], the coordinates of a point in the
        //    reference triangle.
        //
        //    Output, double T(2), the coordinates of the point in
        //    the triangle.
        //
    {
        int i;
        double[] rvert1 = new double[2];
        double[] rvert2 = new double[2];
        double[] rvert3 = new double[2];

        rvert1[0] = -1.0;
        rvert1[1] = -1.0 / Math.Sqrt(3.0);
        rvert2[0] = +1.0;
        rvert2[1] = -1.0 / Math.Sqrt(3.0);
        rvert3[0] = 0.0;
        rvert3[1] = 2.0 / Math.Sqrt(3.0);

        double[] s = triangle_to_simplex(rvert1, rvert2, rvert3, r);

        double[] t = new double[2];

        for (i = 0; i < 2; i++)
        {
            t[i] = tvert1[i] * (1.0 - s[0] - s[1])
                   + tvert2[i] * s[0]
                   + tvert3[i] * s[1];
        }

        return t;
    }
}