<html>

  
<!-- Mirrored from people.math.sc.edu/Burkardt/cpp_src/cvt/cvt.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Oct 2021 15:46:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
      CVT - Centroidal Voronoi Tessellations
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      CVT <br> Centroidal Voronoi Tessellations
    </h1>

    <hr>

    <p>
      <b>CVT</b> 
      is which 
      creates Centroidal Voronoi Tessellation (CVT) datasets.
    </p>

    <p>
      The generation of a CVT dataset is of necessity more complicated than
      for a quasirandom sequence.  An iteration is involved, so there
      must be an initial assignment for the generators, and then a
      number of iterations.  Moreover, in each iteration, estimates must
      be made of the volume and location of the Voronoi cells.  This is
      typically done by Monte Carlo sampling.  The accuracy of the resulting
      CVT depends in part on the number of sampling points and the number
      of iterations taken.  
    </p>

    <p>
      The library is mostly used to generate a dataset of points 
      uniformly distributed in the unit hypersquare.  However, a user 
      may be interested in computations with other geometries or 
      point densities.  To do this, the user needs to replace the
      <b>USER</b> routine in the <b>CVT</b> library, and then specify
      the appropriate values <b>init=3</b> and <b>sample=3</b>.      
    </p>

    <p>
      The <b>USER</b> routine returns a set of sample points from the 
      region of interest.  The default <b>USER</b> routine samples points
      uniformly from the unit circle.  But other geometries are 
      easy to set up.  Changing the point density simply requires
      weighting the sampling in the region.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page 
      are distributed under
      <a href = "https://people.math.sc.edu/Burkardt/txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../box_behnken/box_behnken.html">
      BOX_BEHNKEN</a>, 
      which 
      computes a Box-Behnken design,
      that is, a set of arguments to sample the behavior
      of a function of multiple parameters;
    </p>

    <p>
      <a href = "../ccvt_box/ccvt_box.html">
      CCVT_BOX</a>,
      a C++ program which
      computes a CVT with some points
      forced to lie on the boundary.
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/datasets/cvt/cvt.html">
      CVT</a>,
      a dataset directory which
      contains files describing a number of CVT's.
    </p>

    <p>
      <a href = "../cvt_dataset/cvt_dataset.html">
      CVT_DATASET</a>, 
      a C++ program which
      creates a CVT dataset.
    </p>

    <p>
      <a href = "../faure/faure.html">
      FAURE</a>, 
      which
      computes Faure sequences.
    </p>

    <p>
      <a href = "../grid/grid.html">
      GRID</a>, 
      which
      computes points on a grid.
    </p>

    <p>
      <a href = "../halton/halton.html">
      HALTON</a>, 
      which
      computes Halton
      sequences.
    </p>

    <p>
      <a href = "../hammersley/hammersley.html">
      HAMMERSLEY</a>, 
      which
      computes Hammersley
      sequences.
    </p>

    <p>
      <a href = "../hex_grid/hex_grid.html">
      HEX_GRID</a>, 
      which
      computes sets of points in a 2D hexagonal grid.
    </p>

    <p>
      <a href = "../ihs/ihs.html">
      IHS</a>,  
      which
      computes improved Latin Hypercube datasets.
    </p>

    <p>
      <a href = "../latin_center/latin_center.html">
      LATIN_CENTER</a>, 
      which
      computes Latin square data choosing the center value.
    </p>

    <p>
      <a href = "../latin_edge/latin_edge.html">
      LATIN_EDGE</a>,
      which
      computes Latin square data choosing the edge value.
    </p>

    <p>
      <a href = "../latin_random/latin_random.html">
      LATIN_RANDOM</a>, 
      which
      computes Latin square data choosing a random value in the square.
    </p>

    <p>
      <a href = "../niederreiter2/niederreiter2.html">
      NIEDERREITER2</a>, 
      which
      computes Niederreiter sequences with base 2.
    </p>

    <p>
      <a href = "../normal/normal.html">
      NORMAL</a>, 
      which
      computes elements of a 
      sequence of pseudorandom normally distributed values.
    </p>

    <p>
      <a href = "../sobol/sobol.html">
      SOBOL</a>,
      which
      computes Sobol sequences.
    </p>

    <p>
      <a href = "../uniform/uniform.html">
      UNIFORM</a>, 
      which
      computes uniform random values.
    </p>

    <p>
      <a href = "../van_der_corput/van_der_corput.html">
      VAN_DER_CORPUT</a>, 
      which
      computes van der Corput sequences.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Franz Aurenhammer,<br>
          Voronoi diagrams - 
          a study of a fundamental geometric data structure,<br>
          ACM Computing Surveys,<br>
          Volume 23, Number 3, pages 345-405, September 1991.
        </li>
        <li>
          Paul Bratley, Bennett Fox, Linus Schrage,<br>
          A Guide to Simulation,<br>
          Springer Verlag, pages 201-202, 1983.
        </li>
        <li>
          John Burkardt, Max Gunzburger, Janet Peterson, Rebecca Brannon,<br>
          User Manual and Supporting Information for Library of Codes
          for Centroidal Voronoi Placement and Associated Zeroth,
          First, and Second Moment Determination,<br>
          Sandia National Laboratories Technical Report SAND2002-0099,<br>
          February 2002.
        </li>
        <li>
          Qiang Du, Vance Faber, Max Gunzburger,<br>
          Centroidal Voronoi Tessellations: Applications and Algorithms,<br>
          SIAM Review,<br>
          Volume 41, 1999, pages 637-676.
        </li>
        <li>
          Bennett Fox,<br>
          Algorithm 647:<br>
          Implementation and Relative Efficiency of Quasirandom
          Sequence Generators,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 12, Number 4, pages 362-376, 1986.
        </li>
        <li>
          John Halton,<br>
          On the efficiency of certain quasi-random sequences of points
          in evaluating multi-dimensional integrals,<br>
          Numerische Mathematik,<br>
          Volume 2, pages 84-90, 1960.
        </li>
        <li>
          Lili Ju, Qiang Du, Max Gunzburger,<br>
          Probabilistic methods for centroidal Voronoi tessellations
          and their parallel implementations,<br>
          Parallel Computing,<br>
          Volume 28, 2002, pages 1477-1500.
        </li>
      </ol>
    </p>


    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "cvt_test.txt">cvt_test.txt</a>,
          the output file.
        </li>
        <li>
          <a href = "cvt_circle.txt">cvt_circle.txt</a>,
          a set of 100 CVT points in a circle, generated using
          the built in <b>USER</b> routine.
        </li>
        <li>
          <a href = "cvt_circle.png">cvt_circle.png</a>,
          a PNG image of
          the 100 CVT points in a circle.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <ul>
        <li>
          <b>CH_CAP</b> capitalizes a single character.
        </li>
        <li>
          <b>CH_EQI</b> is true if two characters are equal, disregarding case.
        </li>
        <li>
          <b>CH_TO_DIGIT</b> returns the integer value of a base 10 digit.
        </li>
        <li>
          <b>CVT</b> computes a Centroidal Voronoi Tessellation.
        </li>
        <li>
          <b>CVT_ENERGY</b> computes the CVT energy of a dataset.
        </li>
        <li>
          <b>CVT_ITERATE</b> takes one step of the CVT iteration.
        </li>
        <li>
          <b>CVT_SAMPLE</b> returns sample points.
        </li>
        <li>
          <b>CVT_WRITE</b> writes a CVT dataset to a file.
        </li>
        <li>
          <b>DATA_READ</b> reads generator coordinate data from a file.
        </li>
        <li>
          <b>DIGIT_TO_CH</b> returns the base 10 digit character corresponding to a digit.
        </li>
        <li>
          <b>FIND_CLOSEST</b> finds the nearest R point to each S point.
        </li>
        <li>
          <b>GET_SEED</b> returns a random seed for the random number generator.
        </li>
        <li>
          <b>HALHAM_LEAP_CHECK</b> checks LEAP for a Halton or Hammersley sequence.
        </li>
        <li>
          <b>HALHAM_N_CHECK</b> checks N for a Halton or Hammersley sequence.
        </li>
        <li>
          <b>HALHAM_DIM_NUM_CHECK</b> checks DIM_NUM for a Halton or Hammersley sequence.
        </li>
        <li>
          <b>HALHAM_SEED_CHECK</b> checks SEED for a Halton or Hammersley sequence.
        </li>
        <li>
          <b>HALHAM_STEP_CHECK</b> checks STEP for a Halton or Hammersley sequence.
        </li>
        <li>
          <b>HALTON_BASE_CHECK</b> checks BASE for a Halton sequence.
        </li>
        <li>
          <b>I4_LOG_10</b> returns the whole part of the logarithm base 10 of an integer.
        </li>
        <li>
          <b>I4_MAX</b> returns the maximum of two integers.
        </li>
        <li>
          <b>I4_MIN</b> returns the smaller of two integers.
        </li>
        <li>
          <b>I4_TO_HALTON_SEQUENCE</b> computes N elements of a leaped Halton subsequence.
        </li>
        <li>
          <b>I4_TO_S</b> converts an integer to a string.
        </li>
        <li>
          <b>PRIME</b> returns any of the first PRIME_MAX prime numbers.
        </li>
        <li>
          <b>R8_EPSILON</b> returns the R8 round off unit.
        </li>
        <li>
          <b>R8_HUGE</b> returns a "huge" R8.
        </li>
        <li>
          <b>R8MAT_TRANSPOSE_PRINT</b> prints an R8MAT, transposed.
        </li>
        <li>
          <b>R8MAT_TRANSPOSE_PRINT_SOME</b> prints some of an R8MAT, transposed.
        </li>
        <li>
          <b>R8MAT_UNIFORM_01</b> returns a unit pseudorandom R8MAT.
        </li>
        <li>
          <b>RANDOM_INITIALIZE</b> initializes the RANDOM random number generator.
        </li>
        <li>
          <b>S_EQI</b> reports whether two strings are equal, ignoring case.
        </li>
        <li>
          <b>S_LEN_TRIM</b> returns the length of a string to the last nonblank.
        </li>
        <li>
          <b>S_TO_R8</b> reads an R8 from a string.
        </li>
        <li>
          <b>S_TO_R8VEC</b> reads an R8VEC from a string.
        </li>
        <li>
          <b>TIMESTRING</b> returns the current YMDHMS date as a string.
        </li>
        <li>
          <b>TUPLE_NEXT_FAST</b> computes the next element of a tuple space, "fast".
        </li>
        <li>
          <b>USER</b> samples points in a user-specified region with given density.
        </li>
      </ul>
    </p>


    <hr>

    <i>
      Last revised on 10 November 2006.
    </i>

    <!-- John Burkardt -->


  </body>


<!-- Mirrored from people.math.sc.edu/Burkardt/cpp_src/cvt/cvt.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Oct 2021 15:46:32 GMT -->
</html>
