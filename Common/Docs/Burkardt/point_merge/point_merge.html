<html>

  
<!-- Mirrored from people.math.sc.edu/Burkardt/cpp_src/point_merge/point_merge.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Oct 2021 15:55:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
      POINT_MERGE - Count or Index Unique or Tolerably Unique Points
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      POINT_MERGE <br> Count or Index Unique or Tolerably Unique Points
    </h1>

    <hr>

    <p>
      <b>POINT_MERGE</b>
      is which
      deals with the problem of counting or indexing the unique or
      "tolerably unique" points in a collection of N points in
      M dimensional space.
    </p>

    <p>
      This problem is distinct from, though similar to, problems such
      as finding the nearest neighbor, or counting all the points that
      lie within a given distance of each point, or finding the optimal
      assignment of N points into K clusters (the K-Means problem).
    </p>

    <p>
      The "tolerably unique" problem is the "Starbucks problem", that is,
      the task of choosing a list of Starbucks cafes to shut down, so that
      there is no Starbucks cafe across the street from another one.
      The Starbucks cafes that remain open are "tolerably unique", that
      is, there is now no other open cafe within the given tolerance.
    </p>

    <p>
      Given sets of data with some points very close to each other,
      there are a number of ways of resolving the data.  Here, a simpleminded
      approach is taken, in which we start with one tolerably unique point,
      and consider the remaining points one at a time, accepting the next
      point as long as it is not closer than the tolerance to some already
      accepted point.
    </p>

    <p>
      This is a simpler approach than trying to maximize the number of points
      you can have in the set, while satisfying the tolerance, or of trying
      to replace two nearby points by their average, for instance.
    </p>

    <p>
      For the unique case, in 1D, a simple and efficient procedure sorts
      the data, and then compares consecutive entries.
      For the unique case in multiple dimensions, the sorting procedure
      can still be used.
    </p>

    <p>
      For the "tolerably unique" case in 1D, the same sorting procedure
      can be used, but in multiple dimensions, the usual kinds of lexicographic
      sorting will interleave near and far points in a way that is
      hard to deal with.
    </p>

    <p>
      A reliable method for the tolerably unique case in multiple dimensions
      is simply to compute the distance between every pair of points.
      However, this is an O(N^2) computation, and becomes terribly unsuitable
      when the number of points considered is in the tens of thousands or more.
    </p>

    <p>
      The "radial" approach, implemented in <b>POINT_RADIAL_TOL_UNIQUE_COUNT</b>,
      picks a random base point Z, computes the radial distance R(I) of each point
      P(I) to Z, and then sorts the data by R.  It then counts tolerably unique
      items by inspecting the R array in order.  Two points are possible
      neighbors only if they lie within a TOL interval in R.  Assuming the
      points are in general position, the number of points that need to be
      compared will be small enough that this algorithm is essentially O(N)
      rather than O(N^2).
    </p>

    <p>
      In MATLAB, the <b>unique</b> command can select the unique points;
      there is also a user-written function called <b>consolidator</b>
      that can merge points with a tolerance.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page
      are distributed under
      <a href = "https://people.math.sc.edu/Burkardt/txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>


    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../ann/ann.html">
      ANN</a>,
      which
      computes Approximate Nearest Neighbors,
      by David Mount, Sunil Arya;
    </p>

    <p>
      <a href = "../ann_test/ann_test.html">
      ANN_TEST</a>,
      a C++ program which
      uses <a href = "ann/ann.html">ann</a> to approximate the nearest
      neighbors of a set of points stored in a file;
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/datasets/cities/cities.html">
      CITIES</a>,
      a dataset directory which
      contains sets of information about cities and the distances between them;
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/f_src/cities/cities.html">
      CITIES</a>,
      which
      handles various problems associated with a set of "cities" on a map.
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/f_src/kmeans/kmeans.html">
      KMEANS</a>,
      which
      contains several different algorithms for the K-Means problem.
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/f_src/spaeth/spaeth.html">
      SPAETH</a>,
      which
      can cluster data according to various principles.
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/f_src/spaeth2/spaeth2.html">
      SPAETH2</a>,
      which
      can cluster data according to various principles.
    </p>

    <p>
      <a href = "https://people.math.sc.edu/Burkardt/f_src/table_merge/table_merge.html">
      TABLE_MERGE</a>,
      a FORTRAN90 program which
      reads a file of N points in M dimensions, removes duplicates or points
      that are closer than some tolerance, and writes the reduced set of points
      to a file.
    </p>


    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "point_merge_test.txt">point_merge_test.txt</a>,
          the output file.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <ul>
        <li>
          <b>CPU_TIME</b> reports the elapsed CPU time.
        </li>
        <li>
          <b>I4_MAX</b> returns the maximum of two I4's.
        </li>
        <li>
          <b>I4_MIN</b> returns the minimum of two I4's.
        </li>
        <li>
          <b>I4_UNIFORM</b> returns a scaled pseudorandom I4.
        </li>
        <li>
          <b>POINT_RADIAL_UNIQUE_COUNT</b> counts the unique points.
        </li>
        <li>
          <b>POINT_RADIAL_TOL_UNIQUE_COUNT</b> counts the tolerably unique points.
        </li>
        <li>
          <b>POINT_RADIAL_TOL_UNIQUE_INDEX</b> indexes the tolerably unique points.
        </li>
        <li>
          <b>POINT_TOL_UNIQUE_COUNT</b> counts the tolerably unique points.
        </li>
        <li>
          <b>POINT_TOL_UNIQUE_INDEX</b> indexes the tolerably unique points.
        </li>
        <li>
          <b>POINT_UNIQUE_COUNT</b> counts the unique points.
        </li>
        <li>
          <b>R4_NINT</b> returns the nearest integer to an R4.
        </li>
        <li>
          <b>R8COL_DUPLICATES</b> generates an R8COL with some duplicate columns.
        </li>
        <li>
          <b>R8COL_SORT_HEAP_INDEX_A</b> does an indexed heap ascending sort of an R8COL.
        </li>
        <li>
          <b>R8MAT_TRANSPOSE_PRINT</b> prints an R8MAT, transposed.
        </li>
        <li>
          <b>R8MAT_TRANSPOSE_PRINT_SOME</b> prints some of an R8MAT, transposed.
        </li>
        <li>
          <b>R8MAT_UNIFORM_01</b> returns a unit pseudorandom R8MAT.
        </li>
        <li>
          <b>R8VEC_COMPARE</b> compares two R8VEC's.
        </li>
        <li>
          <b>R8VEC_NORM_L2</b> returns the L2 norm of an R8VEC.
        </li>
        <li>
          <b>R8VEC_PRINT</b> prints an R8VEC.
        </li>
        <li>
          <b>R8VEC_SORT_HEAP_INDEX_A</b> does an indexed heap ascending sort of an R8VEC
        </li>
        <li>
          <b>R8VEC_SUM</b> returns the sum of an R8VEC.
        </li>
        <li>
          <b>R8VEC_UNIFORM_01</b> returns a unit pseudorandom R8VEC.
        </li>
        <li>
          <b>R8VEC_UNIFORM_01_NEW</b> returns a new unit pseudorandom R8VEC.
        </li>
      </ul>
    </p>


    <hr>

    <i>
      Last revised on 24 July 2010.
    </i>

    <!-- John Burkardt -->

  </body>

  <!-- Initial HTML skeleton created by HTMLINDEX. -->


<!-- Mirrored from people.math.sc.edu/Burkardt/cpp_src/point_merge/point_merge.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Oct 2021 15:55:26 GMT -->
</html>
